#+PROPERTY: header-args :exports both :results verbatim

* <2016-02-21 Sun> -- Development Environment
:PROPERTIES:
:header-args: :dir ~/
:END:

** Text Editors vs. IDEs

Loose guidelines:
1. All code is text, so all code can be read in a text editor. Find a /real/, code
   specific text editor with first-class support for code tools like syntax
   highlighting, formatting, and linting -- but other than that? You do you.
2. That said, compiled languages -- Java, for instance -- benefit a lot from
   some of the tools you get with an IDE. IDEs usually aren't general, so it's
   worth getting to know an editor as well, but IDEs are excellent toolkits for
   the specific languages they support.
3. The Text Editor holy war is a crock of nonsense.

*** Editors

Text editors are built for one thing: editing text. (Surprise, right?) A good
text editor supports tools for writing code in many different programming
languages. Microsoft Word? Not a text editor; neither is Google Docs. Text
Editors pair well with using the Terminal directly.

You can use most text editors as-is, but I recommend, at a minimum, that your
editor support and have installed the following tools:
- Syntax Highlighting
- Linting (automatic, often real-time detection of syntax errors)
- Autocompletion

Really nice to have:
- Some kind of integration with revision control
- Search and jump
- ...I dunno, what do /you/ want it to be able to do?

**** Sublime Text and Atom
- Friendly as hell
- Sublime Text (Python); Atom (JavaScript)
- Pretty simple, but that's very good news. (They're *just* text editors.)
- Pretty simple, and maybe you want a little more out of your tools.

**** Emacs
- Type words, get words. (Key chord-driven commands.)
- ...but also it's backed by a lisp! Maybe you think that's great? Maybe it's
  the worst.
- It's a text editor!
- ...and an IDE!
- ...and maybe also an operating system?
- The gold standard in customizabile and extensible editors.

**** Vim
- Type words, get lost
- Modal editing is powerful as hell, once you get your head around it. (And Vim
  is pretty much the only system that gets it right.)
- Extensible with VimScript, which is a hideous nightmare-fuel of a pseudo-language
- Installed by default, in at least some version, on almost every *nix-based
  computer you will ever ever touch.
- Loads almost instantaneously.

**** Note:
Part of the virtue of both Emacs and Vim is that they are first-class text
editors that will run in the Terminal, and/or interact natively with tools like
~ssh~ and ~rsync~. If you're likely to edit files that live on remote servers, it'll
be a great benefit to you to be able to use one of Emacs or Vim with at least
some familiarity.

*** IDEs

**** Emacs again
**** JetBrains IDEAs


** The File System and an introduction to the Terminal

The file system is an interface to the data stored on your computer. Here's the
short short version:

#+BEGIN_QUOTE
The file system represents data in a hierarchy, in which folders contain files,
other folders, and links to files or folders elsewhere in the hierarchy. We can
browse and manipulate this hierarchy with GUI tools, like Finder or Windows
Explorer, or through the Terminal.
#+END_QUOTE

...okay great. What on /earth/ does that mean in practice?

*** File System Basics
Open your terminal. There's a blinking cursor. Your computer is waiting for you
to type a command, tell it what you'd like it to do. Great so far.

When you interact with the file system, you are always /in/ the file system. That
is: your commands always have a context, and that context is some place, some
directory, in the filesystem. When you open your terminal, you start by viewing
the contents of a directory called your ~home~ directory. Every user of a Linux
computer has their own ~home~ dir, specific to them. You can see what directory
you're currently in by typing the  ~pwd~ command and hitting enter, so:

#+BEGIN_SRC sh
pwd
#+END_SRC

#+RESULTS:
: /Users/gastove

Change which directory you're viewing using the ~cd~ command:

#+BEGIN_SRC sh
cd /tmp
pwd
#+END_SRC

#+RESULTS:
: /tmp

Your ~home~ dir has a few special properties we'll get to as we go. First up is:
you can always return to your home directory by typing ~cd~ without specifying
which directory you want to go to:

#+BEGIN_SRC sh :dir /tmp
cd
pwd
#+END_SRC

#+RESULTS:
: /Users/gastove

The directory you're currently /in/ is referred to as your /working directory/. (The
~pwd~ command we used before stands for "print working directory".) You can list
the contents of your working directory with ~ls~:

#+BEGIN_SRC sh
ls
#+END_SRC

#+RESULTS:
#+begin_example
Applications
Code
Desktop
Documents
Downloads
Dropbox
Library
Movies
Music
Pictures
Public
bin
dump.rdb
node_modules
ssl-ca-cert.pem
test.txt
test.txt.gpg
#+end_example

Say it with me: ooooooooooooooh.

*** A few useful keyboard shortcuts

**** Ctrl-c / Ctrl-d
Ctrl-c is the keyboard interrupt command -- if you start something running and
you want it to stop, Ctrl-c will /usually/ help. Ctrl-d is an exit command, useful
for quitting things like the Python REPL.

**** Up/down arrow
As you type commands in to your terminal, your terminal will remember some
number of the last commands you used. Press up arrow to go through your old
commands. (You can go back down with down arrow.)

**** Tab
Tab completion is a beautiful thing. It can be used, most notably, in a lot of
text editors and every Linux terminal. Tab complete can be an excellent way to
see what completions are available, avoid typos, and become *much* faster at using
your computer.

*** Relative vs Absolute Paths
Say your current working directory is your ~home~ dir and you'd like to know the
contents of your ~Documents~ directory. You can achieve that like so:

#+BEGIN_SRC sh
ls /Users/gastove/Documents/
#+END_SRC

#+RESULTS:
#+begin_example
Cornbread Dressing--Traditional Family Style.htm
Cornbread by Mother.htm
Data
Friends
Principal Component Analysis of Binary Data. Applications to Roll-Call-Analysis.pdf
SDS2016KickoffMeetingAgenda.txt
Storage
#+end_example

This is correct, but a little unwieldy -- that's a long command to type. We get
the same effect, however, typing this:

#+BEGIN_SRC sh
ls Documents/
#+END_SRC

#+RESULTS:
#+begin_example
Cornbread Dressing--Traditional Family Style.htm
Cornbread by Mother.htm
Data
Friends
Principal Component Analysis of Binary Data. Applications to Roll-Call-Analysis.pdf
Storage
#+end_example

Here, we're referring to ~Documents~ /relative/ to your home dir. That is, since
the directory ~Documents~ is within the directory ~home~, we can simply say
~Documents~.

There are two other ways to write exactly the same command we've been using:

#+BEGIN_SRC sh :eval never
ls ./Documents/
#+END_SRC

and

#+BEGIN_SRC sh :eval never
ls ~/Documents/
#+END_SRC

The first uses Linux' ~./~ syntax, which means, "here, in current working
directory". The second uses ~, which is a short hand for your ~home~ dir.

Now: what if you want to list the contents of ~/tmp~? The command is exactly what
you'd expect:

#+BEGIN_SRC sh
ls /tmp
#+END_SRC

#+RESULTS:
: KSOutOfProcessFetcher.0.sAglCyxY5lzPoNgfmEvv-ZqGl-w=
: KSOutOfProcessFetcher.501.sAglCyxY5lzPoNgfmEvv-ZqGl-w=
: com.apple.launchd.6NyZdbPEvD
: com.apple.launchd.Ef4hcVmPbo
: com.apple.launchd.Oe9NDK7qNL
: com.apple.launchd.carQq0K5lQ

The leading ~/~ says, "start at the root of the file system". The leading ~/~ is
absolute. Any path starting with a ~/~ is said to be the /fully qualified/ path --
that is, it is *not* relative. Relative paths change with the context of current
working directory; a fully qualified path always refers to the same thing.

Another way to think about this is: relatve paths undergo what's called
"expansion". Under the hood, ~Documents~  and ~~/Documents~ both get "expanded" to
the fully qualified path ~/Users/Documents~. The leading slash means, "don't
expand this, I'm going to tell you exactly what I want."

There's two other things to know with relative paths: ~.~ and ~..~

~.~ (dot) can be a pain, because it's /overloaded/. That is, it means a lot of
different things, depending on context. In the context of paths, dot means
"here" (mentioned briefly above).

~..~ (double-dot) means, "the next level of the hierarchy, going up."

So for instance:

#+BEGIN_SRC sh
ls ~/..
#+END_SRC

#+RESULTS:
: Guest
: Shared
: gastove

Lists the level /up/ from your home dir -- which is to say, it lists all the home
dirs on your computer.

*** A Quick Note about Trailing Slashes

These two commands do exactly the same thing:

#+BEGIN_SRC sh :eval never
ls /tmp

ls /tmp/
#+END_SRC

A trailing slash on a path tells your computer, "this is definitely a path." The
tricky part is, this is optional sometimes and required others. With ~ls~, for
instance, your computer will "do the right thing" and just list whatever you
give it. With things like copying commands -- like ~cp~, ~scp~, and ~rsync~ -- it
becomes very important to say, "this one is a file and this one is a dir". Whee?

*** Hidden Files
A lot of important files on your computer are /hidden/ by default. That is, they
don't show up when you do this:

#+BEGIN_SRC sh
ls ~/
#+END_SRC

But if you do /this/:

#+BEGIN_SRC sh
ls -la ~/
#+END_SRC

You get a *lot* more stuff. Notice all the files with a leading dot? The dot (I
said it was overloaded) tells the operating system not to normally show the
thing with the dot at the front of its name. Dotted files are used as
configuration files of all shapes and varieties, and now you know how to find
them.

For reference: the ~-la~ at the end of the ~ls~ is a type of argument called a
"flag". There are two of them: ~l~ for "list"; ~a~ for "all". We'll be going
over flags in much greater detail later, but for now, ~ls -la~ is an excellent
command to know if you want to see /everything/ in a directory.

*** Links
One last creature in the menagerie to discuss: links. A link makes a kind of
short-cut between one part of the file hierarchy and another. This can be... a
little brain meddling. The salient detail is this: a file linked to a directory
behaves as a member of both directories. You'll see links indicated as an arrow
from link name to the link location, like so:

#+BEGIN_SRC sh
lrwxr-xr-x    1 gastove  staff      37 Dec 11 22:08 .inputrc -> /Users/gastove/.dotfiles/bash/inputrc
#+END_SRC

There's a lot of that here in this document in the Hidden Files section. What
that says is, "if somebody comes looking for the file named .inputrc, give them
the contents of /Users/gastove/.dotfiles/inputrc".

** Package Management
:PROPERTIES:
:header-args: :eval never
:END:
On OS X, this means ~brew~; for all other *nix, it's platform-specific.

On OS X, open your terminal and install homebrew thus:

#+BEGIN_SRC sh
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
#+END_SRC

You can now search for, get information about, and install an incredible array
of packages:

#+BEGIN_SRC sh
brew search git  # What packages with names like "git" are available?
brew info git    # Tell me about the git package!
brew install git # Gimmie git!
#+END_SRC


*Note: Do not use brew with sudo*. You /will/ need to use ~sudo~ to install brew; you
do /not/ need to use sudo to install packages with brew. Let's review:

#+BEGIN_SRC sh
# Correct
brew install git

# NO! NO NO NO!
sudo brew install git # <- DO NOT DO THIS
#+END_SRC

** Regular Expressions
I'm going to wing this if we have time.

* <2016-02-28 Sun> -- OMGWTFDVCS (Git, et al)

** Cleanup                                                        :noexport:
#+BEGIN_SRC sh
rm -rf /tmp/demo*
rm -rf /tmp/*-demo
touch /tmp/export-ran
#+END_SRC

#+RESULTS:

** Version Control: What's the point?

[[http://www.phdcomics.com/comics/archive_print.php?comicid=1531]]

I will not spend a /ton/ of time trying to convince you that version control is
good. Mostly, I'm going to assert that version control is good, and then let
y'all see it in action over the year. But for reference, here's a best-of
version of why you should care:

1. Track your own work in a durable, recoverable way. If you break it, you can
   find the change that broke it; if you remove something you shouldn't have you
   can get it back.
2. Share code with as many people as you want.
3. Incorporate changes from as many contributors as you want without having to
   manually figure out if ~important.txt~ or ~important_latest.txt~ or
   ~important_edits_v2.txt-richards~ or ~imporant_v2_latest.txt.backup.current~ is
   the most important current version.

Version control lets you and your collaborators tell a consistent,
comprehensible story about the development of a body of code. This is very good
news.

** (Distributed) Revision/Version Control
*** Subversion and Co.
There are a lot of older version control systems, of which subversion is the one
I've encountered the most.
*** Mercurial
*** Git
** Git: What Do
Git was originally developed by Linus Torvalds to track development of the Linux
operating system. It is a /distributed/ version control system, meaning that every
copy, or /checkout/, of the code is a parts-complete history of the entire
codebase. Under the covers, git is super neat! And also: you don't have to know
a whole lot about how git works internally to be able to use it capably.

Here are three things that can be useful to know about git:

*** Content-addressable diffing and the sha1 hash
Git is a "Content-addressable" version control framework. What this means in
practice is that git separates a file in to two kinds of things: the /contents/ of
the file and /everything else/ about a file. What is "everything else"? File name,
path within the repo, information about permissions and creation time --
/everything/. This is the property that allows git to compare files from different
creators -- it looks at whether the /contents/ of each file are the same and goes
from there.

*** The .git dir
A "git repository" is actually just a special kind of directory at the root of a
a hierarchy representing a project. So for instance, I have a directory on my
computer named ~2016_sds_lesson_notes~, which is the root of my lesson notes
project. Inside that directory is a directory called ~.git~:

#+BEGIN_SRC sh
ls -la
#+END_SRC

#+RESULTS:
: total 104
: drwxr-xr-x   8 rossdonaldson  staff    272 Feb 27 10:19 .
: drwxr-xr-x   7 rossdonaldson  staff    238 Feb 21 12:49 ..
: drwxr-xr-x  13 rossdonaldson  staff    442 Feb 27 10:13 .git
: -rw-r--r--   1 rossdonaldson  staff      7 Feb 23 20:11 .gitignore
: -rw-r--r--   1 rossdonaldson  staff    154 Feb 21 12:49 README.markdown
: -rw-r--r--   1 rossdonaldson  staff  16693 Feb 21 12:49 lesson_01_development_environment.markdown
: -rw-r--r--   1 rossdonaldson  staff  19669 Feb 27 10:19 master_file.org

(Note that git's folder is named with the leading-dot hidden folder syntax, so
you have to use the ~la~ flags to ~ls~ in order to see it.)

The ~.git~ directory contains everything git knows about your files, their
history, the commits in your repo -- everything is in there. Now: it's in there
mostly in a format /git/ understands. It's not especially human readable. But it's
all there. This has two important implications:

1. Making a project in to a "git repository" changes /nothing/ about the files in
   the repository. Git is perfectly self-contained. If you deleted the ~.git~ dir,
   your directory wouldn't be a git repo any more, and the files would be
   exactly as they were before you deleted the ~.git~ dir.
2. Your project is also self contained. You could move the directory that
   represents your project anywhere on your computer and it would still work
   perfectly normally, still know the same things about your files.

*** Git's configuration files

Git is configured by a set of "dot files" -- files with leading dots. The dot
file you'll interact with the most, by far, is the ~.gitignore~. That said,
setting a ~.gitconfig~ in your home dir will let you configure git's behaviors in
a set of ways you definitely want.

**** .gitconfig
Your ~.gitconfig~ can contain all manner of things: git command aliases, behavior
tweaks, colorization. My minimal ~.gitconfig~ looks like this:

#+BEGIN_SRC sh :eval never
[user]
    name = Ross Donaldson
    email = gastove@gmail.com
[push]
    default = simple
#+END_SRC

Now git knows who I am, what my email address is, and that I want to use the
"simple" push strategy.

**** .gitignore
The ~.gitignore~ is a crucially important part of git: it controls a set of things
that git, by default, will... ignore. (Shocking, I know.) This is ridiculously
important. For instance:

#+BEGIN_SRC sh
mkdir -p /tmp/demo && cd /tmp/demo && git init
echo 'here is some stuff you need to know' > knowledge.txt
echo 'the top secret code is BANANAPHONE. Sure hope nobody ever adds this file to a public git repo' > top_secret.txt
git status
#+END_SRC

#+RESULTS:
#+begin_example
Initialized empty Git repository in /private/tmp/demo/.git/
On branch master

Initial commit

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	knowledge.txt
	top_secret.txt

nothing added to commit but untracked files present (use "git add" to track)
#+end_example

~top_secret.txt~ is untracked, which is fine, but error prone. For instance: ~git
commit -am <message>~ will definitely ~git add~ ~top_secret.txt~ -- which is not what
we want.

Observe:
#+BEGIN_SRC sh :dir /tmp/demo
echo 'top_secret.txt' > .gitignore
git status
#+END_SRC

#+RESULTS:
#+begin_example
On branch master

Initial commit

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	.gitignore
	knowledge.txt

nothing added to commit but untracked files present (use "git add" to track)
#+end_example

Now the ~.gitignore~ exists, but ~top_secret.txt~ has vanished from git
entirely. /Perfect/.

Github will helpfully create a ~.gitignore~ for you when you create a new repo
using the Github UI. A ~.gitignore~ is also a plain text file you can write or
edit yourself.

For the full syntax of the ~.gitignore~, see the [[https://git-scm.com/docs/gitignore][git documentation]].

**** Global vs local vs extra-local
Useful to know: you can have a ~.gitignore~ in any directory, and
git will view them all together, with ~.gitignores~ further down the hierarchy
superseding those further up.

** The basic mental model of Git
Note: while we're discussing git specifically, most of what's discussed here is
directly applicable to many other version control systems -- especially modern
distributed version control systems like mercurial.

Git is a way to change code, over time, such that:
1. You can know how the code changed, from one version to the next
2. You can know extra information /about/ the change -- who made it, when, an
   explanation of why.
3. Many people can make changes at the same time without stepping on each
   others toes.

In order to track changes, with extra information, across contributors, we need
three things:
1. A collective noun for all the code that is inter-related and should be
   considered together.
2. A notion of a unit of change.
3. A way to separate my work from yours from anyone elses that allows our work
   to come back together.

Git provides all three of these things.

*** A Collective Noun for Related Code
Git's unit for related code is called the /repository/ -- or usually just /repo/,
for short. We also sometimes use the word /project/. A repo is all the code that
is needed for the Thing you are Making. For instance: git's source code itself
is in a git repo. All the lesson notes for the 2016 SDS cohort are in a single
git repo.

Repos are usually at their best when they represent roughly one thing:
a single web app; a single program; a single project. /Technically/, a git
repository is just a folder you've told git to keep track of for you; it's up to
you to make sure the contents of your repository make sense.

*** A Unit of Change
Git's unit of change is called a ~commit~. A commit is how we tell git, "I have
made changes that I want to keep track of." Or: "I have made changes that I want
to be part of the official line of development of my code."

A commit is something we, the users of git, construct. We build commits one at a
time, giving them a natural order. We tell get, "add all the changes that
happened to this particular file to the commit I'm currently making." Once we're
satisfied with the state of the current commit, we tell git, "Okay, we're
good. Write this in to the record. Here is a message explaining what I've done
and why."

Git will allow you to build your commits at whatever level of granularity you
want. You can add individual lines from individual files to a commit, or you can
say, "just add absolutely everything that's changed in my entire repo to the
same commit right now." Exactly how you do this is up to you. In general,
however, small, focused commits are much better than huge commits (commits with
hundreds or maybe thousands of lines of changes).

*** A Way to Separate and Come Back Together
Git gives us three invaluable tools for working in parallel, without stepping on
each others toes, while preserving our ability to unite our work whenever we
please. The first tool is called a /branch/; the second is called /cloning/; the
third is a /remote/.

**** Branches
Think of a branch as a line of development. Whenever you add new commits to a
git repo, you're using a branch, whether you know it or not. The principle
branch of a git repo is called /master/, and you can use git happily for a long
time, in some contexts, just committing to master and never knowing a branch is
involved at all.

Branches give us a great deal of power. We can have an effectively unlimited
number of branches in the same repository. Sometimes we'll bring branches back
together (a process called /merging/); sometimes we'll abandon branches and never
come back.

When you branch, you tell git where you're branching /from/, and git creates a new
branch for you. Any commits you add to git will now go to your new branch,
instead of your old branch. You can switch branches at any time; when you do,
git re-writes your repo to match the current branch you have "check out".

We'll talk more about the commands very soon; for now, let's just see what this
looks like:

#+BEGIN_SRC sh
mkdir -p /tmp/branch-demo && cd /tmp/branch-demo && git init # Make a new git repo
echo "1. Pears" > groceries.txt                              # Add an item to a grocery list
git add groceries.txt                                        # Tell git to track groceries.txt
git commit -am "Add pears to list"                           # Commit groceries.txt
git status
#+END_SRC

#+RESULTS:
: Initialized empty Git repository in /private/tmp/branch-demo/.git/
: [master (root-commit) b98e21b] Add pears to list
:  1 file changed, 1 insertion(+)
:  create mode 100644 groceries.txt
: On branch master
: nothing to commit, working directory clean

"On branch master; nothing to commit, working directory clean." ~groceries.txt~
looks like this:
#+NAME: groc_contents
#+BEGIN_SRC sh :dir /tmp/branch-demo :exports both
cat groceries.txt
#+END_SRC

#+RESULTS: groc_contents
: 1. Pears

But now:

#+BEGIN_SRC sh :dir /tmp/branch-demo :exports both
git checkout -b new_branch
echo "2. tofu" >> groceries.txt
git commit -am "Add tofu to list"
git status
#+END_SRC

#+RESULTS:
: [new_branch f6e351f] Add tofu to list
:  1 file changed, 1 insertion(+)
: On branch new_branch
: nothing to commit, working directory clean

~groceries.txt~ looks like this now:

#+BEGIN_SRC sh :dir /tmp/branch-demo :exports both
cat groceries.txt
#+END_SRC

#+RESULTS:
: 1. Pears
: 2. tofu

But now:

#+BEGIN_SRC sh :dir /tmp/branch-demo
git checkout master
cat groceries.txt
#+END_SRC

#+RESULTS:
: 1. Pears

We checkout master... and we're back to the old version. Git has re-written
~groceries.txt~ to match the last commit on the master branch. If we go back to
~new_branch~, our changes are intact:

#+BEGIN_SRC sh :dir /tmp/branch-demo
git checkout new_branch
cat groceries.txt
#+END_SRC

#+RESULTS:
: 1. Pears
: 2. tofu

We can combine the two histories through /merging/:

#+BEGIN_SRC sh :dir /tmp/branch-demo
git checkout master   # We check out the branch we want changes to come *in* to
git merge new_branch  # "Bring the changes from new_branch" in to master
git commit -m "Merging new_branch in to master"
cat groceries.txt
#+END_SRC

#+RESULTS:
: Updating b98e21b..f6e351f
: Fast-forward
:  groceries.txt | 1 +
:  1 file changed, 1 insertion(+)
: On branch master
: nothing to commit, working directory clean
: 1. Pears
: 2. tofu

Shazam.

**** Cloning
Cloning allows us to make our own copy of an existing repo. The metaphor of
"cloning" is actually quite good: our copy (usually called a "checkout") of the
source repository will be exactly identical to the source at time of cloning,
but will grow and develop independently. (The metaphor breaks down when we smash
clones back together. Oh well.)

Any repo can be cloned. For instance, using our repo from the previous example:

#+BEGIN_SRC sh
cd /tmp
git clone ./branch-demo cloning-demo
cd cloning-demo
git status
#+END_SRC

#+RESULTS:
: On branch master
: Your branch is up-to-date with 'origin/master'.
: nothing to commit, working directory clean

We now have a complete second copy to ~branch_demo~ called ~cloning_demo~. It has
its very own copy of ~groceries.txt~:

#+BEGIN_SRC sh :dir /tmp/cloning-demo
pwd
#+END_SRC

#+RESULTS:
: /private/tmp/cloning-demo

#+BEGIN_SRC sh :dir /tmp/cloning-demo
cat groceries.txt
#+END_SRC

#+RESULTS:
: 1. Pears
: 2. tofu

The important thing about cloning is that it can create an exact copy of /any
git repo/, whether it's on your local file system or exposed via a transport
protocol like HTTPS or SSH. This leads us directly in to the notion of
"remotes".

**** Remotes
Git allows us to declare a particular kind of relationship between
repositories. This relationship is called a "remote". The "remote" of a repo is
automatically set during cloning -- your remote is the repo you cloned /from/. A
remote can also be manually declared from the command line.

The "remote" relationship has a number of ramifications.

First: a remote is a source and destination for commits, allowing two developers
to each have their own checkout (clone) of a given repository while still
sharing changes back and forth. For instance: we cloned ~cloning-demo~ from
~branch-demo~, so ~branch-demo~ is a remote for ~cloning-demo~. This means that if
more changes are made in ~branch-demo~, they can be /pulled/ in to ~cloning-demo~:

#+BEGIN_SRC sh
cd /tmp/branch-demo/
echo "3. Gargantua" >> groceries.txt
git commit -am "Add Gargantua to groceries.txt"
#+END_SRC

#+RESULTS:
: [master f8ce545] Add Gargantua to groceries.txt
:  1 file changed, 1 insertion(+)

#+BEGIN_SRC sh
cd /tmp/cloning-demo
cat groceries.txt
#+END_SRC

#+RESULTS:
: 1. Pears
: 2. tofu

#+BEGIN_SRC sh :dir /tmp/cloning-demo
git pull origin master
cat groceries.txt
#+END_SRC

#+RESULTS:
: Updating 18756dc..f8ce545
: Fast-forward
:  groceries.txt | 1 +
:  1 file changed, 1 insertion(+)
: 1. Pears
: 2. tofu
: 3. Gargantua

By using ~git pull~, our checkout now has the changes we made in our remote.

So this is cool and good; we now know we can clone our own checkout of any git
repo, wherever it is, and we can pull new changes from it. But, what if we want
to add our own changes? Good news: git provides for this! However, there's an
issue to consider first:

Pulling changes alters our /working copy/ -- which is to say, we, the developers
currently at the console, make a very deliberate choice to bring new changes in
to the code we're currently working on. The complementary action to pulling is
/pushing/, which sends our changes to our remote. But if our remote is, as in our
current example, a repository on disk that someone else could be editing, life
gets complicated. How much fun would it be to have your working copy change out
from under you? (Answer: no fun at all.)

So: git provides a special class of repositories called "bare" repositories,
/just/ for pulling and pushing changes. Github, for instance, is a web service
that hosts bare repositories, to allow you to pull and push from them
freely.

Remember that we were talking about the First important ramification of remotes?
This is the Second: by establishing bare repositories on servers that are /only/
for pushing and pulling, multiple developers can coordinate their development
efforts.

**** Tying It All Together
The last thing to make sure we all know is that a branch in your local checkout
can be configured to match a branch /on your remote/. In this way, branches can
also be shared, or many developers can work out of the same bare repository,
each working on their own branch. Tidy. Clean.

** Quintessential Git Operations:
:PROPERTIES:
:header-args: :dir /tmp/demo-repo :results verbatim :exports both
:END:
Okay, let's build a git repo.

#+BEGIN_SRC sh :dir ~/ :results verbatim :exports both
cd /tmp
mkdir -p demo-repo
cd demo-repo
pwd
#+END_SRC

#+RESULTS:
: /tmp/demo-repo

We'll make a file -- for ease of seeing line numbers, a grocery list:
#+BEGIN_SRC sh
  touch list.txt
  echo '1. Eggs' >> list.txt
  echo '2. Cheese' >> list.txt
  echo '3. Bacon' >> list.txt
  cat list.txt
#+END_SRC

#+RESULTS:
: 1. Eggs
: 2. Cheese
: 3. Bacon

Good so far.

*** ~git init~
First things first: we need to declare that this folder is a git
repository. This is done with ~git init~, like so:

#+BEGIN_SRC sh
git init
#+END_SRC

#+RESULTS:
: Initialized empty Git repository in /private/tmp/demo-repo/.git/

Perfect! Repo achieved. Notice that the ~init~ command has done exactly what it
tells us it did -- if we check the contents of our working directory:

#+BEGIN_SRC sh
ls -la
#+END_SRC

#+RESULTS:
: total 8
: drwxr-xr-x   4 rossdonaldson  wheel  136 Feb 23 21:10 .
: drwxrwxrwt  14 root           wheel  476 Feb 23 21:03 ..
: drwxr-xr-x   9 rossdonaldson  wheel  306 Feb 23 21:10 .git
: -rw-r--r--   1 rossdonaldson  wheel   27 Feb 23 21:07 list.txt

Now there's a ~.git~. Blam.

*** ~git status~
Git will tell us about a repo's present state using the ~git status~
command. Right now, the output is a little thin:

#+BEGIN_SRC sh
git status
#+END_SRC

#+RESULTS:
#+begin_example
On branch master

Initial commit

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	list.txt

nothing added to commit but untracked files present (use "git add" to track)
#+end_example

We learn which branch we're on (master), that the commit we're building will be
the very first (i.e. the Initial commit), and that there's a single, un-tracked
file. Not so exciting right now, but we'll be coming back to this command a
*lot*.

*** ~git add~
If the repo is going to do us any good, we'll want to start tracking our
list. Remember that in git, you /build/ a commit by adding changes to it. One kind
of change is, "I made this file".

So, before:

#+BEGIN_SRC sh
git status
#+END_SRC

#+RESULTS:
#+begin_example
On branch master

Initial commit

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	list.txt

nothing added to commit but untracked files present (use "git add" to track)
#+end_example

And after:

#+BEGIN_SRC sh
git add list.txt
git status
#+END_SRC

#+RESULTS:
: On branch master
:
: Initial commit
:
: Changes to be committed:
:   (use "git rm --cached <file>..." to unstage)
:
: 	new file:   list.txt
:

Okay! More informative! We've got a command on unstaging (look further through
this doc for more on that), and list.txt is now known as a "new file"! Progress.

Now, an *important thing*: check out what happens if we now change the file:

#+BEGIN_SRC sh
  echo '4. kale' >> list.txt
  git status
#+END_SRC

#+RESULTS:
: On branch master
:
: Initial commit
:
: Changes to be committed:
:   (use "git rm --cached <file>..." to unstage)
:
: 	new file:   list.txt
:

Note that our new change has /not/ been added to the current commit. We'll go
ahead and fix that now:

#+BEGIN_SRC sh
  git add list.txt
  git status
#+END_SRC

#+RESULTS:
: On branch master
:
: Initial commit
:
: Changes to be committed:
:   (use "git rm --cached <file>..." to unstage)
:
: 	new file:   list.txt
:

*** ~git commit~
Now that we've built our shiny new commit, let's go ahead and commit it:

#+BEGIN_SRC sh
  git commit -m "Initial commit of a grocery list"
#+END_SRC

#+RESULTS:
: [master (root-commit) 0e991f1] Initial commit of a grocery list
:  1 file changed, 3 insertions(+)
:  create mode 100644 list.txt

Let's break this down: ~git commit~ is our command -- it's the most salient thing
happening. That ~-m~ flag is worth unpacking.

See, every commit needs a commit message. That message needs to be written
someplace. If you were to simply type ~git commit~, git would say, "neat! let's
get a commit message written," and open the default editor for your
computer. For most computers, that editor is... Vim. Which is a wonderful tool
if you know it well, and a bewildering headache if you don't.

~-m~, then, lets us specify the commit message as a command-line argument. Good
stuff, eh?

*Protip* -- if you're confident in the changes on your branch, you can also use
~git commit -am <your message>~, which automatically adds /and/ commits all
uncommitted changes in all tracked files.

Anywho:

#+BEGIN_SRC sh
git status
#+END_SRC

#+RESULTS:
: On branch master
: nothing to commit, working directory clean

Now we get a very terse message: working directory clean. Nothing to see
here. Everything is committed. /Ahhhhh/.

*** ~git branch~
Come with me on this one: let's say we want to be tidy grocery list developers
and we decide to start working on a new branch. To start with, we should see
what branches are available to us:
#+BEGIN_SRC sh
git branch
#+END_SRC

#+RESULTS:
: * master

Okay, only the one so far. The asterisk indicates that ~master~ is our current
branch. We can make a new branch like so:

#+BEGIN_SRC sh
git branch list_dev
git branch
#+END_SRC

#+RESULTS:
:   list_dev
: * master

We've created a new branch... but we're still on master. To actually /use/ our new
branch, we need the next git command: ~checkout~.

*** ~git checkout~
Git checkout is a) incredibly useful and b) painfully overloaded, meaning it
does different things depending on exactly how you use it. Right now, what we
care about is using ~git checkout~ to let us switch between branches:

#+BEGIN_SRC sh
git checkout list_dev
git status
#+END_SRC

#+RESULTS:
: On branch list_dev
: nothing to commit, working directory clean

There! Now we're on branch ~list_dev~: ~git branch~ confirms it:

#+BEGIN_SRC sh
git branch
#+END_SRC

#+RESULTS:
: * list_dev
:   master

There's an extra-awesome way to use ~git checkout~: with the ~-b~ flag. ~git checkout
-b <branch_name>~ does three good things at once:

1. Creates a new branch named ~<branch_name>~
2. Switches you to it
3. Moves any uncommitted changes from your old branch to your new branch.

#+BEGIN_SRC sh
echo "4. Orange Juice" >> list.txt
git checkout -b even_list_devier
git status
#+END_SRC

#+RESULTS:
: M	list.txt
: On branch even_list_devier
: Changes not staged for commit:
:   (use "git add <file>..." to update what will be committed)
:   (use "git checkout -- <file>..." to discard changes in working directory)
:
: 	modified:   list.txt
:
: no changes added to commit (use "git add" and/or "git commit -a")

Now, there's a *second crucially important* thing ~git checkout~ lets you do:
recover deleted files or past states. So, for instance: I'm going to make a
directory full of important files:

#+BEGIN_SRC sh
mkdir -p so_important
for i in 1 2 3; do touch so_important/critical_$i; done
tree
#+END_SRC

#+RESULTS:
: .
: |-- list.txt
: `-- so_important
:     |-- critical_1
:     |-- critical_2
:     `-- critical_3
:
: 1 directory, 4 files

Git doesn't know about this yet, so let's add it:

#+BEGIN_SRC sh
git add so_important
git commit -am "This is so important. Add it!"
#+END_SRC

#+RESULTS:
: [even_list_devier 65456b6] This is so important. Add it!
:  4 files changed, 2 insertions(+)
:  create mode 100644 so_important/critical_1
:  create mode 100644 so_important/critical_2
:  create mode 100644 so_important/critical_3

And now, let's do a poorly considered delete:

#+BEGIN_SRC sh
rm -rf so_important
ls -la
#+END_SRC

#+RESULTS:
: total 8
: drwxr-xr-x   4 rossdonaldson  wheel  136 Feb 27 15:34 .
: drwxrwxrwt  19 root           wheel  646 Feb 27 15:33 ..
: drwxr-xr-x  12 rossdonaldson  wheel  408 Feb 27 15:34 .git
: -rw-r--r--   1 rossdonaldson  wheel   59 Feb 27 15:14 list.txt

Well crap. All our important stuff is completely gone. /Except/, we were smart
developers and added it to git! Git knows something is up:

#+BEGIN_SRC sh
git status
#+END_SRC

#+RESULTS:
#+begin_example
On branch even_list_devier
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	deleted:    so_important/critical_1
	deleted:    so_important/critical_2
	deleted:    so_important/critical_3

no changes added to commit (use "git add" and/or "git commit -a")
#+end_example

It tells us we've deleted all those files. We can bring them back with ~git
checkout~:

#+BEGIN_SRC sh
git checkout -- so_important/*
tree
#+END_SRC

#+RESULTS:
: .
: |-- list.txt
: `-- so_important
:     |-- critical_1
:     |-- critical_2
:     `-- critical_3
:
: 1 directory, 4 files

Blam. Git saves the day.

*** ~git remote~
Probably if we have changes, we wanna share them with the world, eh? I mean,
maybe not -- maybe you're hacking on a one-off project and you don't know if
it'll really "work" yet, y'know? But for now, today, right now: let's assume
sharing is on the menu. "But wait," you say, "I haven't set up a place to share
this!" Git agrees:

#+BEGIN_SRC sh
git push
#+END_SRC

#+BEGIN_EXAMPLE
fatal: No configured push destination.
Either specify the URL from the command-line or configure a remote repository using

    git remote add <name> <url>

and then push using the remote name

    git push <name>
#+END_EXAMPLE

To spare my github account, I'm going to create a bare repo locally:

#+BEGIN_SRC sh
cd /tmp && git clone --bare demo-repo demo-remote
#+END_SRC

I can now add my remote to my original repo:

#+BEGIN_SRC sh
git remote add origin /tmp/demo-remote
#+END_SRC

By convention, we call the "primary" remote of a repo "origin" (which makes
considerably more sense if you think of cloning a repo from Github -- Github is
then your "origin".)

We can see that we have a remote set:

#+BEGIN_SRC sh
git remote
#+END_SRC

#+RESULTS:
: origin

Using git's verbose flag, ~-v~, we can learn a little more about ~origin~:

#+BEGIN_SRC sh
git remote -v
#+END_SRC

#+RESULTS:
: origin	/tmp/demo-remote (fetch)
: origin	/tmp/demo-remote (push)

This means, by default, ~git fetch~ and ~git push~ will both refer to ~git fetch
origin~ and ~git push origin~. Perfect!


*** ~git push~
Now that we've set a remote, we can /push/ changes from our checkout to the
remote, allowing those changes to be shared. First, a word about upstream
branches.

So far, locally, we've made a variety of branches. We're about to push from a
branch to our remote. What happens to those commits? Do they wind up all on the
same branch on the remote? Or do they get a branch that matches what we've got
locally? The answer is: we can tell git to do it however we'd like. What we're
describing here is called the "upstream branch" -- which branch does
~even_list_devier~ get pushed to on our remote? The best practice here is that you
should push your local branch to a branch of the same name on your
remote. Here's how to do this:

First, when we push, we can manually specify a remote and a branch on the remote:

#+BEGIN_SRC sh
git push origin even_list_devier
#+END_SRC

This command gets a little tiresome, so we typically use the ~--set-upstream~ flag
to tell git, "remember where I push so I don't have to type the full command in
the future":

#+BEGIN_SRC sh
git push --set-upstream origin even_list_devier
#+END_SRC

#+RESULTS:
: Branch even_list_devier set up to track remote branch even_list_devier from origin.

Now that this has been saved, we can see our upstreams by passing the /double
verbose/ flag, ~-vv~, to  ~git branch~:

#+BEGIN_SRC sh
git branch -vv
#+END_SRC

#+RESULTS:
: * even_list_devier 65456b6 [origin/even_list_devier] This is so important. Add it!
:   list_dev         0e991f1 Initial commit of a grocery list
:   master           0e991f1 Initial commit of a grocery list

~[origin/even_list_devier]~ means that ~even_list_devier~ is "tracking" an eponymous
remote branch on ~origin~. Yatta!

Now, we can make that command a little shorter. Remember in the <<.gitconfig>>
section, I set my "push strategy" to "simple"?  This means that when I say ~git
push~, git automatically assumes that I mean ~git push <upstream_branch>~.

#+BEGIN_SRC sh
echo "5. Gold Rings" >> list.txt
git commit -am "Adding 5 Gold Rings to grocery list"
git push
#+END_SRC

#+RESULTS:
: [even_list_devier 3023675] Adding 5 Gold Rings to grocery list
:  1 file changed, 1 insertion(+)

Lovely.

*** ~git fetch~ and ~git pull~
Git gives us two ways to retrieve new commits from our remote: ~fetch~ and
~pull~. First, I'll create a second checkout of our remote, so we can see this in
action:

#+BEGIN_SRC sh
cd /tmp && git clone ./demo-remote demo-second-clone
#+END_SRC

In demo-second-clone, I can use the ~-av~ syntax (all, verbose) to see what
branches are on the remote:

#+BEGIN_SRC sh :dir /tmp/demo-second-clone :exports both
git branch -av
#+END_SRC

#+RESULTS:
: * even_list_devier 3023675 Adding 5 Gold Rings to grocery list

Ah, of course. We never pushed ~master~ or ~list_dev~, so they aren't on the remote
at all. Let's fix that:

#+BEGIN_SRC sh
cd /tmp/demo-repo
git checkout list_dev
git push --set-upstream origin list_dev
git checkout master
git push --set-upstream origin master
#+END_SRC

#+RESULTS:
: Branch list_dev set up to track remote branch list_dev from origin.
: Branch master set up to track remote branch master from origin.

Now, back in demo-second-clone:
#+BEGIN_SRC sh :dir /tmp/demo-second-clone :exports both
git branch -avv
#+END_SRC

#+RESULTS:
: * even_list_devier                3023675 [origin/even_list_devier] Adding 5 Gold Rings to grocery list
:   remotes/origin/HEAD             -> origin/even_list_devier
:   remotes/origin/even_list_devier 3023675 Adding 5 Gold Rings to grocery list
:   remotes/origin/list_dev         0e991f1 Initial commit of a grocery list
:   remotes/origin/master           0e991f1 Initial commit of a grocery list

There. Now, let's see what ~git status~ in demo-second-clone has to say:

#+BEGIN_SRC sh :dir /tmp/demo-second-clone :exports both
git status
#+END_SRC

#+RESULTS:
: On branch even_list_devier
: Your branch is up-to-date with 'origin/even_list_devier'.
: nothing to commit, working directory clean

It says we're up-to-date with ~origin/even_list_devier~ -- but we know that's not
true, because we pushed a commit from ~demo-repo~. We can ask the remote to tell
us about commits we're missing using ~git fetch~:

#+BEGIN_SRC sh :dir /tmp/demo-second-clone :exports both
git fetch
git status
#+END_SRC

#+RESULTS:
: On branch even_list_devier
: Your branch is behind 'origin/even_list_devier' by 1 commit, and can be fast-forwarded.
:   (use "git pull" to update your local branch)
: nothing to commit, working directory clean

Ah! There we go. We are "behind" by 1 commit, as expected. The thing to notice
is that ~git fetch~ /has not changed anything/. We know what we're missing, but the
current state of our files is no different:

#+BEGIN_SRC sh :dir /tmp/demo-second-clone :exports both
cat list.txt
#+END_SRC

#+RESULTS:
: 1. Eggs
: 2. Cheese
: 3. Bacon
: 4. Orange Juice
: 4. Orange Juice
: 5. Gold Rings

~git pull~ is the command that will actually bring changes from the remote /in to
our working copy/:

#+BEGIN_SRC sh :dir /tmp/demo-second-clone :exports both
git pull
#+END_SRC

#+RESULTS:
: Updating 3023675..941d224
: Fast-forward
:  list.txt | 1 +
:  1 file changed, 1 insertion(+)

#+BEGIN_SRC sh :dir /tmp/demo-second-clone :exports both
cat list.txt
#+END_SRC

#+RESULTS:
: 1. Eggs
: 2. Cheese
: 3. Bacon
: 4. Orange Juice
: 4. Orange Juice
: 5. Gold Rings
: 6. is a good number

Voila.


* <2016-03-06 Sun> -- BASH BASH BASH: The Terminal, the Shell, and a Thousand Little Programs
** What on Earth Even Is This
** The Environment and the PATH
*** ~printenv~
*** ~export~
** You Should Totally Get Familiar With:
*** ~ls~

#+BEGIN_SRC sh
ls -la $HOME
#+END_SRC

*** ~mkdir~
*** ~rm~
*** ~cat~
*** ~head~ and ~tail~
*** ~grep~
*** ~top~
*** ~ps~

** If you work on remote servers:
*** ~ssh~
*** ~ping~
*** ~rsync~

** Good to know is there:
*** ~uniq~
*** ~sort~
*** ~wc~
*** ~sed~
*** ~cut~

** For the brave: ~awk~
*** ~strace~
*** ~netstat~
* <2016-03-13 Sun> -- Writing Good Python
** PEP-8: Not Just a Good Idea
** There's a Tool For That
* <2016-04-03 Sun> -- Web Servers: What do?
* <2016-04-10 Sun> -- Welcome to Databases
* <2016-04-17 Sun> -- Database, Part Two: Electric Boogaloo
* <2016-04-24 Sun> -- Testing. Testing. Testing.
