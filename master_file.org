 #+PROPERTY: header-args :exports both :results verbatim

* <2017-01-31 Tue> -- Development Environment
:PROPERTIES:
:header-args: :dir ~/
:EXPORT_FILE_NAME: lesson_01_development_environment.html
:END:

** Foundational Idea: Plain Text
You've probably used Microsoft Word. You've probably used it to do a thing like
this:

1. Open a new Document.
2. Write five works.
3. Make one of them bold.
4. Change the font size.
5. Change the font entirely.
6. Save it.
7. Email it to someone else.

First point of clarification: when you save the document, it becomes a /file/, a
thing that exists on the hard drive of your computer. We could call it a
document, because we know it is; now we can call it a "file" too. A file is a
much broader term; nearly anything stored on your computer is a file, or is made
of files. (The primary exception are folders, which collect a set of files and
other folders, making a natural hierarchy.) Point is: I'm going to say
"document" and "file" a little interchangeably for a moment here.

When that document arrives in the inbox of the Other Person, and they open it in
Microsoft Word, you will have a very reasonable expectation that it will be "the
same". Which is to say, not /only/ will the words be the same, but the font will
be the same, and the correct word will be typeset in a bold face.

This sort of file is called a /rich text/ document. Which means: the document
encodes both data ("what words are in the document") and metadata about those
words ("this one is bold; the font is Impact") and saves them in the same file.
You need a particular kind of program to correctly interact with this file;
you'd have a gross experience opening a Word document in Sublime Text.

This markdown document, on the other hand, is a /plain text/ document. It *only*
contains words. What font will it open in? A font provided by the program that
opens it. How big will the text be? You can't control that either. A plain text
format conveys *only* the data -- the words -- and no metadata.

This distinction is important for a variety of reasons. The most important of
them is this: unlike Word Documents, where the program used to write them is
prescribed by the format, plain text documents can be opened and edited by a
dazzling array of programs. Plain text can also be manipulated by an incredibly
rich set of tools. Today, we're going to explore some of these.

** Text Editors vs. IDEs

"Text editor" is the name for the broad category of tools intended for working
with plain text. There are a *lot* of IDEs, and many of them don't bear fooling
with. Windows, for example, comes with a program called Notepad. If Text Editors
are cars, Notepad is a golf cart with half a battery left. It'll move you a
short distance, sure, and then you'll wish you'd done something else.

An Integrated Development Environment -- IDE -- ties a text editor together with
Some Number of Other Tools. Which tools, and how they are tied together, varies
widely. And yes, the line between an editor and an IDE can get fuzzy.

Loose guidelines:
1. All code is text, so all code can be read in a text editor. Find a /real/, code
   specific text editor with first-class support for code tools like syntax
   highlighting, formatting, and linting -- but other than that? You do you.
2. That said, compiled languages -- Java, for instance -- benefit a lot from
   some of the tools you get with an IDE. IDEs usually aren't general, so it's
   worth getting to know an editor as well, but IDEs are excellent toolkits for
   the specific languages they support.
3. The Text Editor holy war is a crock of nonsense.

*** Editors

Text editors are built for one thing: editing text. (Surprise, right?) A good
text editor supports tools for writing code in many different programming
languages. Microsoft Word? Not a text editor; neither is Google Docs. Text
Editors pair well with using the Terminal directly.

You can use most text editors as-is, but I recommend, at a minimum, that your
editor support and have installed the following tools:
- Syntax Highlighting
- Linting (automatic, often real-time detection of syntax errors)
- Autocompletion

Really nice to have:
- Some kind of integration with revision control
- Search and jump
- ...I dunno, what do /you/ want it to be able to do?

**** Sublime Text and Atom
- Friendly as hell
- Sublime Text (Python); Atom (JavaScript)
- Pretty simple, but that's very good news. (They're *just* text editors.)
- Pretty simple, and maybe you want a little more out of your tools.

**** Nano
- Look, this is technically a text editor
- But it's a little like the Notepad of unix

Nano is a wonderful thing to know is there in a context where you might
otherwise have to use Vim, assuming you do not presently know how to use Vim.

**** Emacs
- Type words, get words. (Key chord-driven commands.)
- ...but also it's backed by a lisp! Maybe you think that's great? Maybe it's
  the worst.
- It's a text editor!
- ...and an IDE!
- ...and maybe also an operating system?
- The gold standard in customizabile and extensible editors.
- The gold standard in truly idiosyncratic user experiences.

**** Vim
- Type words, get lost
- Modal editing is powerful as hell, once you get your head around it. (And Vim
  is pretty much the only system that gets it right.)
- Extensible with VimScript, which is a hideous nightmare-fuel of a pseudo-language
- Installed by default, in at least some version, on almost every *nix-based
  computer you will ever ever touch.
- Loads almost instantaneously.

**** Note:
Part of the virtue of both Emacs and Vim is that they are first-class text
editors that will run in the Terminal, and/or interact natively with tools like
~ssh~ and ~rsync~. If you're likely to edit files that live on remote servers, it'll
be a great benefit to you to be able to use one of Emacs or Vim with at least
some familiarity.

*** IDEs

**** Emacs again
**** JetBrains IDEAs


** The File System and an introduction to the Terminal

The file system is an interface to the data stored on your computer. Here's the
short short version:

#+BEGIN_QUOTE
The file system represents data in a hierarchy, in which folders contain files,
other folders, and links to files or folders elsewhere in the hierarchy. We can
browse and manipulate this hierarchy with GUI tools, like Finder or Windows
Explorer, or through the Terminal.
#+END_QUOTE

...okay great. What on /earth/ does that mean in practice?

*** File System Basics
Open your terminal. There's a blinking cursor. Your computer is waiting for you
to type a command, tell it what you'd like it to do. Great so far.

When you interact with the file system, you are always /in/ the file system. That
is: your commands always have a context, and that context is some place, some
directory, in the filesystem. When you open your terminal, you start by viewing
the contents of a directory called your ~home~ directory. Every user of a Linux
computer has their own ~home~ dir, specific to them. You can see what directory
you're currently in by typing the  ~pwd~ command and hitting enter, so:

#+BEGIN_SRC sh
pwd
#+END_SRC

#+RESULTS:
: /Users/gastove

Change which directory you're viewing using the ~cd~ command:

#+BEGIN_SRC sh
cd /tmp/
pwd
#+END_SRC

#+RESULTS:
: /tmp

Your ~home~ dir has a few special properties we'll get to as we go. First up is:
you can always return to your home directory by typing ~cd~ without specifying
which directory you want to go to:

#+BEGIN_SRC sh :dir /tmp
cd
pwd
#+END_SRC

#+RESULTS:
: /Users/gastove

The directory you're currently /in/ is referred to as your /working directory/. (The
~pwd~ command we used before stands for "print working directory".) You can list
the contents of your working directory with ~ls~:

#+BEGIN_SRC sh
ls
#+END_SRC

#+RESULTS:
#+begin_example
Applications
Code
Desktop
Documents
Downloads
Dropbox
Library
Movies
Music
Pictures
Public
bin
dump.rdb
node_modules
ssl-ca-cert.pem
test.txt
test.txt.gpg
#+end_example

Say it with me: ooooooooooooooh.

*** A few useful keyboard shortcuts

**** Ctrl-c / Ctrl-d
Ctrl-c is the keyboard interrupt command -- if you start something running and
you want it to stop, Ctrl-c will /usually/ help. Ctrl-d is an exit command, useful
for quitting things like the Python REPL.

**** Up/down arrow
As you type commands in to your terminal, your terminal will remember some
number of the last commands you used. Press up arrow to go through your old
commands. (You can go back down with down arrow.)

**** Ctrl-r
Speaking of previous commands that you've used, you can also search through
those remembered commands with Ctrl-r. Just hit Ctrl-r, and start typing some
part of the command you are looking for. Once you have a few characters typed
and start seeing good results, hitting Ctrl-r again will take you to the
previous matching command you typed. You can cancel at any time with Ctrl-g.

**** Tab
Tab completion is a beautiful thing. It can be used, most notably, in a lot of
text editors and every Linux terminal. Tab complete can be an excellent way to
see what completions are available, avoid typos, and become *much* faster at using
your computer.

*** Relative vs Absolute Paths
Say your current working directory is your ~home~ dir and you'd like to know the
contents of your ~Documents~ directory. You can achieve that like so:

#+BEGIN_SRC sh
ls /Users/gastove/Documents/
#+END_SRC

#+RESULTS:
#+begin_example
Cornbread Dressing--Traditional Family Style.htm
Cornbread by Mother.htm
Data
Friends
Principal Component Analysis of Binary Data. Applications to Roll-Call-Analysis.pdf
SDS2016KickoffMeetingAgenda.txt
Storage
#+end_example

This is correct, but a little unwieldy -- that's a long command to type. We get
the same effect, however, typing this:

#+BEGIN_SRC sh
ls Documents/
#+END_SRC

#+RESULTS:
#+begin_example
Cornbread Dressing--Traditional Family Style.htm
Cornbread by Mother.htm
Data
Friends
Principal Component Analysis of Binary Data. Applications to Roll-Call-Analysis.pdf
Storage
#+end_example

Here, we're referring to ~Documents~ /relative/ to your home dir. That is, since
the directory ~Documents~ is within the directory ~home~, we can simply say
~Documents~.

There are two other ways to write exactly the same command we've been using:

#+BEGIN_SRC sh :eval never
ls ./Documents/
#+END_SRC

and

#+BEGIN_SRC sh :eval never
ls ~/Documents/
#+END_SRC

The first uses Linux' ~./~ syntax, which means, "here, in current working
directory". The second uses ~, which is a short hand for your ~home~ dir.

Now: what if you want to list the contents of ~/tmp~? The command is exactly what
you'd expect:

#+BEGIN_SRC sh
ls /tmp
#+END_SRC

#+RESULTS:
: KSOutOfProcessFetcher.0.sAglCyxY5lzPoNgfmEvv-ZqGl-w=
: KSOutOfProcessFetcher.501.sAglCyxY5lzPoNgfmEvv-ZqGl-w=
: com.apple.launchd.6NyZdbPEvD
: com.apple.launchd.Ef4hcVmPbo
: com.apple.launchd.Oe9NDK7qNL
: com.apple.launchd.carQq0K5lQ

The leading ~/~ says, "start at the root of the file system". The leading ~/~ is
absolute. Any path starting with a ~/~ is said to be the /fully qualified/ path --
that is, it is *not* relative. Relative paths change with the context of current
working directory; a fully qualified path always refers to the same thing.

Another way to think about this is: relatve paths undergo what's called
"expansion". Under the hood, ~Documents~  and ~~/Documents~ both get "expanded" to
the fully qualified path ~/Users/Documents~. The leading slash means, "don't
expand this, I'm going to tell you exactly what I want."

There's two other things to know with relative paths: ~.~ and ~..~

~.~ (dot) can be a pain, because it's /overloaded/. That is, it means a lot of
different things, depending on context. In the context of paths, dot means
"here" (mentioned briefly above).

~..~ (double-dot) means, "the next level of the hierarchy, going up."

So for instance:

#+BEGIN_SRC sh
ls ~/..
#+END_SRC

#+RESULTS:
: Guest
: Shared
: gastove

Lists the level /up/ from your home dir -- which is to say, it lists all the home
dirs on your computer.

*** A Quick Note about Trailing Slashes

These two commands do exactly the same thing:

#+BEGIN_SRC sh :eval never
ls /tmp

ls /tmp/
#+END_SRC

A trailing slash on a path tells your computer, "this is definitely a path." The
tricky part is, this is optional sometimes and required others. With ~ls~, for
instance, your computer will "do the right thing" and just list whatever you
give it. With things like copying commands -- like ~cp~, ~scp~, and ~rsync~ -- it
becomes very important to say, "this one is a file and this one is a dir". Whee?

*** Hidden Files
A lot of important files on your computer are /hidden/ by default. That is, they
don't show up when you do this:

#+BEGIN_SRC sh
ls ~/
#+END_SRC

But if you do /this/:

#+BEGIN_SRC sh
ls -la ~/
#+END_SRC

You get a *lot* more stuff. Notice all the files with a leading dot? The dot (I
said it was overloaded) tells the operating system not to normally show the
thing with the dot at the front of its name. Dotted files are used as
configuration files of all shapes and varieties, and now you know how to find
them.

For reference: the ~-la~ at the end of the ~ls~ is a type of argument called a
"flag". There are two of them: ~l~ for "list"; ~a~ for "all". We'll be going
over flags in much greater detail later, but for now, ~ls -la~ is an excellent
command to know if you want to see /everything/ in a directory.

*** Links
One last creature in the menagerie to discuss: links. A link makes a kind of
short-cut between one part of the file hierarchy and another. This can be... a
little brain meddling. The salient detail is this: a file linked to a directory
behaves as a member of both directories. You'll see links indicated as an arrow
from link name to the link location, like so:

#+BEGIN_SRC sh
lrwxr-xr-x    1 gastove  staff      37 Dec 11 22:08 .inputrc -> /Users/gastove/.dotfiles/bash/inputrc
#+END_SRC

There's a lot of that here in this document in the Hidden Files section. What
that says is, "if somebody comes looking for the file named .inputrc, give them
the contents of /Users/gastove/.dotfiles/inputrc".

** Package Management
:PROPERTIES:
:header-args: :eval never
:END:
On OS X, this means ~brew~; for all other *nix, it's platform-specific.

On OS X, open your terminal and install homebrew thus:

#+BEGIN_SRC sh
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
#+END_SRC

You can now search for, get information about, and install an incredible array
of packages:

#+BEGIN_SRC sh
brew search git  # What packages with names like "git" are available?
brew info git    # Tell me about the git package!
brew install git # Gimmie git!
#+END_SRC


*Note: Do not use brew with sudo*. You /will/ need to use ~sudo~ to install brew; you
do /not/ need to use sudo to install packages with brew. Let's review:

#+BEGIN_SRC sh
# Correct
brew install git

# NO! NO NO NO!
sudo brew install git # <- DO NOT DO THIS
#+END_SRC

** Homework
1. Accept github invite!
2. Slack all set up and ready to go!
3. Read Blabs' [[https://github.com/reed-college/blabs-config][configuration file]]; think about gifs or commands to add next week.
4. Play with text editors! Figure out how to install a linter. Learn how to jump
   forward/backaward up/down by word/sentence/paragraph. Learn how to jump from
   an opening symbol, like {, to it's matching close, }.
5. Start thinking about users you care about! Who would you want to build for?

* <2017-02-07 Tue> -- OMGWTFDVCS (Git, et al)
:PROPERTIES:
:EXPORT_FILE_NAME: lesson_02_git.html
:END:

** Cleanup                                                        :noexport:
#+BEGIN_SRC sh
rm -rf /tmp/demo*
rm -rf /tmp/*-demo
touch /tmp/export-ran
#+END_SRC

#+RESULTS:

** Version Control: What's the point?

[[http://www.phdcomics.com/comics/archive_print.php?comicid=1531]]

I will not spend a /ton/ of time trying to convince you that version control is
good. Mostly, I'm going to assert that version control is good, and then let
y'all see it in action over the year. But for reference, here's a best-of
version of why you should care:

1. Track your own work in a durable, recoverable way. If you break it, you can
   find the change that broke it; if you remove something you shouldn't have you
   can get it back.
2. Share code with as many people as you want.
3. Incorporate changes from as many contributors as you want without having to
   manually figure out if ~important.txt~ or ~important_latest.txt~ or
   ~important_edits_v2.txt-richards~ or ~imporant_v2_latest.txt.backup.current~ is
   the most important current version.

Version control lets you and your collaborators tell a consistent,
comprehensible story about the development of a body of code. This is very good
news.

** (Distributed) Revision/Version Control
*** Subversion and Co.
There are a lot of older version control systems, of which subversion is the one
I've encountered the most.
*** Mercurial
*** Git
** Git: What Do
Git was originally developed by Linus Torvalds to track development of the Linux
operating system. It is a /distributed/ version control system, meaning that every
copy, or /checkout/, of the code is a parts-complete history of the entire
codebase. Under the covers, git is super neat! And also: you don't have to know
a whole lot about how git works internally to be able to use it capably.

Here are three things that can be useful to know about git:

*** Content-addressable diffing and the sha1 hash
Git is a "Content-addressable" version control framework. What this means in
practice is that git separates a file in to two kinds of things: the /contents/ of
the file and /everything else/ about a file. What is "everything else"? File name,
path within the repo, information about permissions and creation time --
/everything/. This is the property that allows git to compare files from different
creators -- it looks at whether the /contents/ of each file are the same and goes
from there.

*** The .git dir
A "git repository" is actually just a special kind of directory at the root of a
a hierarchy representing a project. So for instance, I have a directory on my
computer named ~2016_sds_lesson_notes~, which is the root of my lesson notes
project. Inside that directory is a directory called ~.git~:

#+BEGIN_SRC sh
ls -la
#+END_SRC

#+RESULTS:
: total 104
: drwxr-xr-x   8 rossdonaldson  staff    272 Feb 27 10:19 .
: drwxr-xr-x   7 rossdonaldson  staff    238 Feb 21 12:49 ..
: drwxr-xr-x  13 rossdonaldson  staff    442 Feb 27 10:13 .git
: -rw-r--r--   1 rossdonaldson  staff      7 Feb 23 20:11 .gitignore
: -rw-r--r--   1 rossdonaldson  staff    154 Feb 21 12:49 README.markdown
: -rw-r--r--   1 rossdonaldson  staff  16693 Feb 21 12:49 lesson_01_development_environment.markdown
: -rw-r--r--   1 rossdonaldson  staff  19669 Feb 27 10:19 master_file.org

(Note that git's folder is named with the leading-dot hidden folder syntax, so
you have to use the ~la~ flags to ~ls~ in order to see it.)

The ~.git~ directory contains everything git knows about your files, their
history, the commits in your repo -- everything is in there. Now: it's in there
mostly in a format /git/ understands. It's not especially human readable. But it's
all there. This has two important implications:

1. Making a project in to a "git repository" changes /nothing/ about the files in
   the repository. Git is perfectly self-contained. If you deleted the ~.git~ dir,
   your directory wouldn't be a git repo any more, and the files would be
   exactly as they were before you deleted the ~.git~ dir.
2. Your project is also self contained. You could move the directory that
   represents your project anywhere on your computer and it would still work
   perfectly normally, still know the same things about your files.

*** Git's configuration files

Git is configured by a set of "dot files" -- files with leading dots. The dot
file you'll interact with the most, by far, is the ~.gitignore~. That said,
setting a ~.gitconfig~ in your home dir will let you configure git's behaviors in
a set of ways you definitely want.

**** .gitconfig
Your ~.gitconfig~ can contain all manner of things: git command aliases, behavior
tweaks, colorization. My minimal ~.gitconfig~ looks like this:

#+BEGIN_SRC sh :eval never
[user]
    name = Ross Donaldson
    email = gastove@gmail.com
[push]
    default = simple
#+END_SRC

Now git knows who I am, what my email address is, and that I want to use the
"simple" push strategy.

**** .gitignore
The ~.gitignore~ is a crucially important part of git: it controls a set of things
that git, by default, will... ignore. (Shocking, I know.) This is ridiculously
important. For instance:

#+BEGIN_SRC sh
mkdir -p /tmp/demo && cd /tmp/demo && git init
echo 'here is some stuff you need to know' > knowledge.txt
echo 'the top secret code is BANANAPHONE. Sure hope nobody ever adds this file to a public git repo' > top_secret.txt
git status
#+END_SRC

#+RESULTS:
#+begin_example
Initialized empty Git repository in /private/tmp/demo/.git/
On branch master

Initial commit

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        knowledge.txt
        top_secret.txt

nothing added to commit but untracked files present (use "git add" to track)
#+end_example

~top_secret.txt~ is untracked, which is fine, but error prone. For instance: ~git
commit -am <message>~ will definitely ~git add~ ~top_secret.txt~ -- which is not what
we want.

Observe:
#+BEGIN_SRC sh :dir /tmp/demo
echo 'top_secret.txt' > .gitignore
git status
#+END_SRC

#+RESULTS:
#+begin_example
On branch master

Initial commit

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        .gitignore
        knowledge.txt

nothing added to commit but untracked files present (use "git add" to track)
#+end_example

Now the ~.gitignore~ exists, but ~top_secret.txt~ has vanished from git
entirely. /Perfect/.

Github will helpfully create a ~.gitignore~ for you when you create a new repo
using the Github UI. A ~.gitignore~ is also a plain text file you can write or
edit yourself.

For the full syntax of the ~.gitignore~, see the [[https://git-scm.com/docs/gitignore][git documentation]].

**** Global vs local vs extra-local
Useful to know: you can have a ~.gitignore~ in any directory, and
git will view them all together, with ~.gitignores~ further down the hierarchy
superseding those further up.

** The basic mental model of Git
Note: while we're discussing git specifically, most of what's discussed here is
directly applicable to many other version control systems -- especially modern
distributed version control systems like mercurial.

Git is a way to change code, over time, such that:
1. You can know how the code changed, from one version to the next
2. You can know extra information /about/ the change -- who made it, when, an
   explanation of why.
3. Many people can make changes at the same time without stepping on each
   others toes.

In order to track changes, with extra information, across contributors, we need
three things:
1. A collective noun for all the code that is inter-related and should be
   considered together.
2. A notion of a unit of change.
3. A way to separate my work from yours from anyone elses that allows our work
   to come back together.

Git provides all three of these things.

*** A Collective Noun for Related Code
Git's unit for related code is called the /repository/ -- or usually just /repo/,
for short. We also sometimes use the word /project/. A repo is all the code that
is needed for the Thing you are Making. For instance: git's source code itself
is in a git repo. All the lesson notes for the 2016 SDS cohort are in a single
git repo.

Repos are usually at their best when they represent roughly one thing:
a single web app; a single program; a single project. /Technically/, a git
repository is just a folder you've told git to keep track of for you; it's up to
you to make sure the contents of your repository make sense.

*** A Unit of Change
Git's unit of change is called a ~commit~. A commit is how we tell git, "I have
made changes that I want to keep track of." Or: "I have made changes that I want
to be part of the official line of development of my code."

A commit is something we, the users of git, construct. We build commits one at a
time, giving them a natural order. We tell get, "add all the changes that
happened to this particular file to the commit I'm currently making." Once we're
satisfied with the state of the current commit, we tell git, "Okay, we're
good. Write this in to the record. Here is a message explaining what I've done
and why."

Git will allow you to build your commits at whatever level of granularity you
want. You can add individual lines from individual files to a commit, or you can
say, "just add absolutely everything that's changed in my entire repo to the
same commit right now." Exactly how you do this is up to you. In general,
however, small, focused commits are much better than huge commits (commits with
hundreds or maybe thousands of lines of changes).

*** A Way to Separate and Come Back Together
Git gives us three invaluable tools for working in parallel, without stepping on
each others toes, while preserving our ability to unite our work whenever we
please. The first tool is called a /branch/; the second is called /cloning/; the
third is a /remote/.

**** Branches
Think of a branch as a line of development. Whenever you add new commits to a
git repo, you're using a branch, whether you know it or not. The principle
branch of a git repo is called /master/, and you can use git happily for a long
time, in some contexts, just committing to master and never knowing a branch is
involved at all.

Branches give us a great deal of power. We can have an effectively unlimited
number of branches in the same repository. Sometimes we'll bring branches back
together (a process called /merging/); sometimes we'll abandon branches and never
come back.

When you branch, you tell git where you're branching /from/, and git creates a new
branch for you. Any commits you add to git will now go to your new branch,
instead of your old branch. You can switch branches at any time; when you do,
git re-writes your repo to match the current branch you have "check out".

We'll talk more about the commands very soon; for now, let's just see what this
looks like:

#+BEGIN_SRC sh
mkdir -p /tmp/branch-demo && cd /tmp/branch-demo && git init # Make a new git repo
echo "1. Pears" > groceries.txt                              # Add an item to a grocery list
git add groceries.txt                                        # Tell git to track groceries.txt
git commit -am "Add pears to list"                           # Commit groceries.txt
git status
#+END_SRC

#+RESULTS:
: Initialized empty Git repository in /private/tmp/branch-demo/.git/
: [master (root-commit) b98e21b] Add pears to list
:  1 file changed, 1 insertion(+)
:  create mode 100644 groceries.txt
: On branch master
: nothing to commit, working directory clean

"On branch master; nothing to commit, working directory clean." ~groceries.txt~
looks like this:
#+NAME: groc_contents
#+BEGIN_SRC sh :dir /tmp/branch-demo :exports both
cat groceries.txt
#+END_SRC

#+RESULTS: groc_contents
: 1. Pears

But now:

#+BEGIN_SRC sh :dir /tmp/branch-demo :exports both
git checkout -b new_branch
echo "2. tofu" >> groceries.txt
git commit -am "Add tofu to list"
git status
#+END_SRC

#+RESULTS:
: [new_branch f6e351f] Add tofu to list
:  1 file changed, 1 insertion(+)
: On branch new_branch
: nothing to commit, working directory clean

~groceries.txt~ looks like this now:

#+BEGIN_SRC sh :dir /tmp/branch-demo :exports both
cat groceries.txt
#+END_SRC

#+RESULTS:
: 1. Pears
: 2. tofu

But now:

#+BEGIN_SRC sh :dir /tmp/branch-demo
git checkout master
cat groceries.txt
#+END_SRC

#+RESULTS:
: 1. Pears

We checkout master... and we're back to the old version. Git has re-written
~groceries.txt~ to match the last commit on the master branch. If we go back to
~new_branch~, our changes are intact:

#+BEGIN_SRC sh :dir /tmp/branch-demo
git checkout new_branch
cat groceries.txt
#+END_SRC

#+RESULTS:
: 1. Pears
: 2. tofu

We can combine the two histories through /merging/:

#+BEGIN_SRC sh :dir /tmp/branch-demo
git checkout master   # We check out the branch we want changes to come *in* to
git merge new_branch  # "Bring the changes from new_branch" in to master
git commit -m "Merging new_branch in to master"
cat groceries.txt
#+END_SRC

#+RESULTS:
: Updating b98e21b..f6e351f
: Fast-forward
:  groceries.txt | 1 +
:  1 file changed, 1 insertion(+)
: On branch master
: nothing to commit, working directory clean
: 1. Pears
: 2. tofu

Shazam.

**** Cloning
Cloning allows us to make our own copy of an existing repo. The metaphor of
"cloning" is actually quite good: our copy (usually called a "checkout") of the
source repository will be exactly identical to the source at time of cloning,
but will grow and develop independently. (The metaphor breaks down when we smash
clones back together. Oh well.)

Any repo can be cloned. For instance, using our repo from the previous example:

#+BEGIN_SRC sh
cd /tmp
git clone ./branch-demo cloning-demo
cd cloning-demo
git status
#+END_SRC

#+RESULTS:
: On branch master
: Your branch is up-to-date with 'origin/master'.
: nothing to commit, working directory clean

We now have a complete second copy to ~branch_demo~ called ~cloning_demo~. It has
its very own copy of ~groceries.txt~:

#+BEGIN_SRC sh :dir /tmp/cloning-demo
pwd
#+END_SRC

#+RESULTS:
: /private/tmp/cloning-demo

#+BEGIN_SRC sh :dir /tmp/cloning-demo
cat groceries.txt
#+END_SRC

#+RESULTS:
: 1. Pears
: 2. tofu

The important thing about cloning is that it can create an exact copy of /any
git repo/, whether it's on your local file system or exposed via a transport
protocol like HTTPS or SSH. This leads us directly in to the notion of
"remotes".

**** Remotes
Git allows us to declare a particular kind of relationship between
repositories. This relationship is called a "remote". The "remote" of a repo is
automatically set during cloning -- your remote is the repo you cloned /from/. A
remote can also be manually declared from the command line.

The "remote" relationship has a number of ramifications.

First: a remote is a source and destination for commits, allowing two developers
to each have their own checkout (clone) of a given repository while still
sharing changes back and forth. For instance: we cloned ~cloning-demo~ from
~branch-demo~, so ~branch-demo~ is a remote for ~cloning-demo~. This means that if
more changes are made in ~branch-demo~, they can be /pulled/ in to ~cloning-demo~:

#+BEGIN_SRC sh
cd /tmp/branch-demo/
echo "3. Gargantua" >> groceries.txt
git commit -am "Add Gargantua to groceries.txt"
#+END_SRC

#+RESULTS:
: [master f8ce545] Add Gargantua to groceries.txt
:  1 file changed, 1 insertion(+)

#+BEGIN_SRC sh
cd /tmp/cloning-demo
cat groceries.txt
#+END_SRC

#+RESULTS:
: 1. Pears
: 2. tofu

#+BEGIN_SRC sh :dir /tmp/cloning-demo
git pull origin master
cat groceries.txt
#+END_SRC

#+RESULTS:
: Updating 18756dc..f8ce545
: Fast-forward
:  groceries.txt | 1 +
:  1 file changed, 1 insertion(+)
: 1. Pears
: 2. tofu
: 3. Gargantua

By using ~git pull~, our checkout now has the changes we made in our remote.

So this is cool and good; we now know we can clone our own checkout of any git
repo, wherever it is, and we can pull new changes from it. But, what if we want
to add our own changes? Good news: git provides for this! However, there's an
issue to consider first:

Pulling changes alters our /working copy/ -- which is to say, we, the developers
currently at the console, make a very deliberate choice to bring new changes in
to the code we're currently working on. The complementary action to pulling is
/pushing/, which sends our changes to our remote. But if our remote is, as in our
current example, a repository on disk that someone else could be editing, life
gets complicated. How much fun would it be to have your working copy change out
from under you? (Answer: no fun at all.)

So: git provides a special class of repositories called "bare" repositories,
/just/ for pulling and pushing changes. Github, for instance, is a web service
that hosts bare repositories, to allow you to pull and push from them
freely.

Remember that we were talking about the First important ramification of remotes?
This is the Second: by establishing bare repositories on servers that are /only/
for pushing and pulling, multiple developers can coordinate their development
efforts.

**** Tying It All Together
The last thing to make sure we all know is that a branch in your local checkout
can be configured to match a branch /on your remote/. In this way, branches can
also be shared, or many developers can work out of the same bare repository,
each working on their own branch. Tidy. Clean.

** The Pull Request
So how does this all work for a software development workflow? There are a lot
of answers to this question. We'll be using a fairly standard practice, which
goes like this:

1. You decide you want to contribute to a project; you find it on github and
   clone it locally.
2. You use ~git checkout -b <branch name>~ to make a new branch (a "topic" or
   "feature" branch) to contain your work.
3. You work for a while, committing your work as you go. Every now and then, you
   use ~git push~, to make sure your branch is available on the remote and that
   everything is up-to-date.
4. Every now and then, you make sure you're keeping up with ~master~ by merging it
   in like this:
   1. Make sure all of your work is committed on your branch.
   2. Check out the ~master~ branch and do a ~git pull~ to be sure it's up-to-date.
   3. If there are new commits on ~master~, check out your topic branch and ~git
      merge master~. Resolve any merge conflicts.
5. When you're ready to fully contribute your work, you do it like so:
   1. Make sure you're up to date with ~master~, exactly like in step 4.
   2. ~git push~ your changes to the remote (github).
   3. Open the repo on github; create a new pull request.
   4. Share it around! Get code review.
      1. Make any changes suggested in code review.
   5. When you're ready, merge and delete your topic branch.


** Quintessential Git Operations:
:PROPERTIES:
:header-args: :dir /tmp/demo-repo :results verbatim :exports both
:END:
Okay, let's build a git repo.

#+BEGIN_SRC sh :dir ~/ :results verbatim :exports both
cd /tmp
mkdir -p demo-repo
cd demo-repo
pwd
#+END_SRC

#+RESULTS:
: /tmp/demo-repo

We'll make a file -- for ease of seeing line numbers, a grocery list:
#+BEGIN_SRC sh
  touch list.txt
  echo '1. Eggs' >> list.txt
  echo '2. Cheese' >> list.txt
  echo '3. Bacon' >> list.txt
  cat list.txt
#+END_SRC

#+RESULTS:
: 1. Eggs
: 2. Cheese
: 3. Bacon

Good so far.

*** ~git init~
First things first: we need to declare that this folder is a git
repository. This is done with ~git init~, like so:

#+BEGIN_SRC sh
git init
#+END_SRC

#+RESULTS:
: Initialized empty Git repository in /private/tmp/demo-repo/.git/

Perfect! Repo achieved. Notice that the ~init~ command has done exactly what it
tells us it did -- if we check the contents of our working directory:

#+BEGIN_SRC sh
ls -la
#+END_SRC

#+RESULTS:
: total 8
: drwxr-xr-x   4 rossdonaldson  wheel  136 Feb 23 21:10 .
: drwxrwxrwt  14 root           wheel  476 Feb 23 21:03 ..
: drwxr-xr-x   9 rossdonaldson  wheel  306 Feb 23 21:10 .git
: -rw-r--r--   1 rossdonaldson  wheel   27 Feb 23 21:07 list.txt

Now there's a ~.git~. Blam.

*** ~git status~
Git will tell us about a repo's present state using the ~git status~
command. Right now, the output is a little thin:

#+BEGIN_SRC sh
git status
#+END_SRC

#+RESULTS:
#+begin_example
On branch master

Initial commit

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        list.txt

nothing added to commit but untracked files present (use "git add" to track)
#+end_example

We learn which branch we're on (master), that the commit we're building will be
the very first (i.e. the Initial commit), and that there's a single, un-tracked
file. Not so exciting right now, but we'll be coming back to this command a
*lot*.

*** ~git add~
If the repo is going to do us any good, we'll want to start tracking our
list. Remember that in git, you /build/ a commit by adding changes to it. One kind
of change is, "I made this file".

So, before:

#+BEGIN_SRC sh
git status
#+END_SRC

#+RESULTS:
#+begin_example
On branch master

Initial commit

Untracked files:
  (use "git add <file>..." to include in what will be committed)

        list.txt

nothing added to commit but untracked files present (use "git add" to track)
#+end_example

And after:

#+BEGIN_SRC sh
git add list.txt
git status
#+END_SRC

#+RESULTS:
: On branch master
:
: Initial commit
:
: Changes to be committed:
:   (use "git rm --cached <file>..." to unstage)
:
:       new file:   list.txt
:

Okay! More informative! We've got a command on unstaging (look further through
this doc for more on that), and list.txt is now known as a "new file"! Progress.

Now, an *important thing*: check out what happens if we now change the file:

#+BEGIN_SRC sh
  echo '4. kale' >> list.txt
  git status
#+END_SRC

#+RESULTS:
: On branch master
:
: Initial commit
:
: Changes to be committed:
:   (use "git rm --cached <file>..." to unstage)
:
:       new file:   list.txt
:

Note that our new change has /not/ been added to the current commit. We'll go
ahead and fix that now:

#+BEGIN_SRC sh
  git add list.txt
  git status
#+END_SRC

#+RESULTS:
: On branch master
:
: Initial commit
:
: Changes to be committed:
:   (use "git rm --cached <file>..." to unstage)
:
:       new file:   list.txt
:

*** ~git commit~
Now that we've built our shiny new commit, let's go ahead and commit it:

#+BEGIN_SRC sh
  git commit -m "Initial commit of a grocery list"
#+END_SRC

#+RESULTS:
: [master (root-commit) 0e991f1] Initial commit of a grocery list
:  1 file changed, 3 insertions(+)
:  create mode 100644 list.txt

Let's break this down: ~git commit~ is our command -- it's the most salient thing
happening. That ~-m~ flag is worth unpacking.

See, every commit needs a commit message. That message needs to be written
someplace. If you were to simply type ~git commit~, git would say, "neat! let's
get a commit message written," and open the default editor for your
computer. For most computers, that editor is... Vim. Which is a wonderful tool
if you know it well, and a bewildering headache if you don't.

~-m~, then, lets us specify the commit message as a command-line argument. Good
stuff, eh?

*Protip* -- if you're confident in the changes on your branch, you can also use
~git commit -am <your message>~, which automatically adds /and/ commits all
uncommitted changes in all tracked files.

Anywho:

#+BEGIN_SRC sh
git status
#+END_SRC

#+RESULTS:
: On branch master
: nothing to commit, working directory clean

Now we get a very terse message: working directory clean. Nothing to see
here. Everything is committed. /Ahhhhh/.

*** ~git branch~
Come with me on this one: let's say we want to be tidy grocery list developers
and we decide to start working on a new branch. To start with, we should see
what branches are available to us:
#+BEGIN_SRC sh
git branch
#+END_SRC

#+RESULTS:
: * master

Okay, only the one so far. The asterisk indicates that ~master~ is our current
branch. We can make a new branch like so:

#+BEGIN_SRC sh
git branch list_dev
git branch
#+END_SRC

#+RESULTS:
:   list_dev
: * master

We've created a new branch... but we're still on master. To actually /use/ our new
branch, we need the next git command: ~checkout~.

*** ~git checkout~
Git checkout is a) incredibly useful and b) painfully overloaded, meaning it
does different things depending on exactly how you use it. Right now, what we
care about is using ~git checkout~ to let us switch between branches:

#+BEGIN_SRC sh
git checkout list_dev
git status
#+END_SRC

#+RESULTS:
: On branch list_dev
: nothing to commit, working directory clean

There! Now we're on branch ~list_dev~: ~git branch~ confirms it:

#+BEGIN_SRC sh
git branch
#+END_SRC

#+RESULTS:
: * list_dev
:   master

There's an extra-awesome way to use ~git checkout~: with the ~-b~ flag. ~git checkout
-b <branch_name>~ does three good things at once:

1. Creates a new branch named ~<branch_name>~
2. Switches you to it
3. Moves any uncommitted changes from your old branch to your new branch.

#+BEGIN_SRC sh
echo "4. Orange Juice" >> list.txt
git checkout -b even_list_devier
git status
#+END_SRC

#+RESULTS:
: M     list.txt
: On branch even_list_devier
: Changes not staged for commit:
:   (use "git add <file>..." to update what will be committed)
:   (use "git checkout -- <file>..." to discard changes in working directory)
:
:       modified:   list.txt
:
: no changes added to commit (use "git add" and/or "git commit -a")

Now, there's a *second crucially important* thing ~git checkout~ lets you do:
recover deleted files or past states. So, for instance: I'm going to make a
directory full of important files:

#+BEGIN_SRC sh
mkdir -p so_important
for i in 1 2 3; do touch so_important/critical_$i; done
tree
#+END_SRC

#+RESULTS:
: .
: |-- list.txt
: `-- so_important
:     |-- critical_1
:     |-- critical_2
:     `-- critical_3
:
: 1 directory, 4 files

Git doesn't know about this yet, so let's add it:

#+BEGIN_SRC sh
git add so_important
git commit -am "This is so important. Add it!"
#+END_SRC

#+RESULTS:
: [even_list_devier 65456b6] This is so important. Add it!
:  4 files changed, 2 insertions(+)
:  create mode 100644 so_important/critical_1
:  create mode 100644 so_important/critical_2
:  create mode 100644 so_important/critical_3

And now, let's do a poorly considered delete:

#+BEGIN_SRC sh
rm -rf so_important
ls -la
#+END_SRC

#+RESULTS:
: total 8
: drwxr-xr-x   4 rossdonaldson  wheel  136 Feb 27 15:34 .
: drwxrwxrwt  19 root           wheel  646 Feb 27 15:33 ..
: drwxr-xr-x  12 rossdonaldson  wheel  408 Feb 27 15:34 .git
: -rw-r--r--   1 rossdonaldson  wheel   59 Feb 27 15:14 list.txt

Well crap. All our important stuff is completely gone. /Except/, we were smart
developers and added it to git! Git knows something is up:

#+BEGIN_SRC sh
git status
#+END_SRC

#+RESULTS:
#+begin_example
On branch even_list_devier
Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        deleted:    so_important/critical_1
        deleted:    so_important/critical_2
        deleted:    so_important/critical_3

no changes added to commit (use "git add" and/or "git commit -a")
#+end_example

It tells us we've deleted all those files. We can bring them back with ~git
checkout~:

#+BEGIN_SRC sh
git checkout -- so_important/*
tree
#+END_SRC

#+RESULTS:
: .
: |-- list.txt
: `-- so_important
:     |-- critical_1
:     |-- critical_2
:     `-- critical_3
:
: 1 directory, 4 files

Blam. Git saves the day.

*** ~git remote~
Probably if we have changes, we wanna share them with the world, eh? I mean,
maybe not -- maybe you're hacking on a one-off project and you don't know if
it'll really "work" yet, y'know? But for now, today, right now: let's assume
sharing is on the menu. "But wait," you say, "I haven't set up a place to share
this!" Git agrees:

#+BEGIN_SRC sh
git push
#+END_SRC

#+BEGIN_EXAMPLE
fatal: No configured push destination.
Either specify the URL from the command-line or configure a remote repository using

    git remote add <name> <url>

and then push using the remote name

    git push <name>
#+END_EXAMPLE

To spare my github account, I'm going to create a bare repo locally:

#+BEGIN_SRC sh
cd /tmp && git clone --bare demo-repo demo-remote
#+END_SRC

I can now add my remote to my original repo:

#+BEGIN_SRC sh
git remote add origin /tmp/demo-remote
#+END_SRC

By convention, we call the "primary" remote of a repo "origin" (which makes
considerably more sense if you think of cloning a repo from Github -- Github is
then your "origin".)

We can see that we have a remote set:

#+BEGIN_SRC sh
git remote
#+END_SRC

#+RESULTS:
: origin

Using git's verbose flag, ~-v~, we can learn a little more about ~origin~:

#+BEGIN_SRC sh
git remote -v
#+END_SRC

#+RESULTS:
: origin        /tmp/demo-remote (fetch)
: origin        /tmp/demo-remote (push)

This means, by default, ~git fetch~ and ~git push~ will both refer to ~git fetch
origin~ and ~git push origin~. Perfect!


*** ~git push~
Now that we've set a remote, we can /push/ changes from our checkout to the
remote, allowing those changes to be shared. First, a word about upstream
branches.

So far, locally, we've made a variety of branches. We're about to push from a
branch to our remote. What happens to those commits? Do they wind up all on the
same branch on the remote? Or do they get a branch that matches what we've got
locally? The answer is: we can tell git to do it however we'd like. What we're
describing here is called the "upstream branch" -- which branch does
~even_list_devier~ get pushed to on our remote? The best practice here is that you
should push your local branch to a branch of the same name on your
remote. Here's how to do this:

First, when we push, we can manually specify a remote and a branch on the remote:

#+BEGIN_SRC sh
git push origin even_list_devier
#+END_SRC

This command gets a little tiresome, so we typically use the ~--set-upstream~ flag
to tell git, "remember where I push so I don't have to type the full command in
the future":

#+BEGIN_SRC sh
git push --set-upstream origin even_list_devier
#+END_SRC

#+RESULTS:
: Branch even_list_devier set up to track remote branch even_list_devier from origin.

Now that this has been saved, we can see our upstreams by passing the /double
verbose/ flag, ~-vv~, to  ~git branch~:

#+BEGIN_SRC sh
git branch -vv
#+END_SRC

#+RESULTS:
: * even_list_devier 65456b6 [origin/even_list_devier] This is so important. Add it!
:   list_dev         0e991f1 Initial commit of a grocery list
:   master           0e991f1 Initial commit of a grocery list

~[origin/even_list_devier]~ means that ~even_list_devier~ is "tracking" an eponymous
remote branch on ~origin~. Yatta!

Now, we can make that command a little shorter. Remember in the <<.gitconfig>>
section, I set my "push strategy" to "simple"?  This means that when I say ~git
push~, git automatically assumes that I mean ~git push <upstream_branch>~.

#+BEGIN_SRC sh
echo "5. Gold Rings" >> list.txt
git commit -am "Adding 5 Gold Rings to grocery list"
git push
#+END_SRC

#+RESULTS:
: [even_list_devier 3023675] Adding 5 Gold Rings to grocery list
:  1 file changed, 1 insertion(+)

Lovely.

*** ~git fetch~ and ~git pull~
Git gives us two ways to retrieve new commits from our remote: ~fetch~ and
~pull~. First, I'll create a second checkout of our remote, so we can see this in
action:

#+BEGIN_SRC sh
cd /tmp && git clone ./demo-remote demo-second-clone
#+END_SRC

In demo-second-clone, I can use the ~-av~ syntax (all, verbose) to see what
branches are on the remote:

#+BEGIN_SRC sh :dir /tmp/demo-second-clone :exports both
git branch -av
#+END_SRC

#+RESULTS:
: * even_list_devier 3023675 Adding 5 Gold Rings to grocery list

Ah, of course. We never pushed ~master~ or ~list_dev~, so they aren't on the remote
at all. Let's fix that:

#+BEGIN_SRC sh
cd /tmp/demo-repo
git checkout list_dev
git push --set-upstream origin list_dev
git checkout master
git push --set-upstream origin master
#+END_SRC

#+RESULTS:
: Branch list_dev set up to track remote branch list_dev from origin.
: Branch master set up to track remote branch master from origin.

Now, back in demo-second-clone:
#+BEGIN_SRC sh :dir /tmp/demo-second-clone :exports both
git branch -avv
#+END_SRC

#+RESULTS:
: * even_list_devier                3023675 [origin/even_list_devier] Adding 5 Gold Rings to grocery list
:   remotes/origin/HEAD             -> origin/even_list_devier
:   remotes/origin/even_list_devier 3023675 Adding 5 Gold Rings to grocery list
:   remotes/origin/list_dev         0e991f1 Initial commit of a grocery list
:   remotes/origin/master           0e991f1 Initial commit of a grocery list

There. Now, let's see what ~git status~ in demo-second-clone has to say:

#+BEGIN_SRC sh :dir /tmp/demo-second-clone :exports both
git status
#+END_SRC

#+RESULTS:
: On branch even_list_devier
: Your branch is up-to-date with 'origin/even_list_devier'.
: nothing to commit, working directory clean

It says we're up-to-date with ~origin/even_list_devier~ -- but we know that's not
true, because we pushed a commit from ~demo-repo~. We can ask the remote to tell
us about commits we're missing using ~git fetch~:

#+BEGIN_SRC sh :dir /tmp/demo-second-clone :exports both
git fetch
git status
#+END_SRC

#+RESULTS:
: On branch even_list_devier
: Your branch is behind 'origin/even_list_devier' by 1 commit, and can be fast-forwarded.
:   (use "git pull" to update your local branch)
: nothing to commit, working directory clean

Ah! There we go. We are "behind" by 1 commit, as expected. The thing to notice
is that ~git fetch~ /has not changed anything/. We know what we're missing, but the
current state of our files is no different:

#+BEGIN_SRC sh :dir /tmp/demo-second-clone :exports both
cat list.txt
#+END_SRC

#+RESULTS:
: 1. Eggs
: 2. Cheese
: 3. Bacon
: 4. Orange Juice
: 4. Orange Juice
: 5. Gold Rings

~git pull~ is the command that will actually bring changes from the remote /in to
our working copy/:

#+BEGIN_SRC sh :dir /tmp/demo-second-clone :exports both
git pull
#+END_SRC

#+RESULTS:
: Updating 3023675..941d224
: Fast-forward
:  list.txt | 1 +
:  1 file changed, 1 insertion(+)

#+BEGIN_SRC sh :dir /tmp/demo-second-clone :exports both
cat list.txt
#+END_SRC

#+RESULTS:
: 1. Eggs
: 2. Cheese
: 3. Bacon
: 4. Orange Juice
: 4. Orange Juice
: 5. Gold Rings
: 6. is a good number

Voila.

** Homework
1. Clone [[https://github.com/reed-college/blabs-config][blabs' config file]] to your computer. Read it and understand it.
2. Contribute a new command, or expand an old one!
3. Open a pull request. Heck! Open two!
4. When you open a pull request, post it in the interns channel; I'll review
   every single one of them. Y'all are welcome to review each others code --
   just remember to be kind. Ask questions! Learn things :D
5. Once I approve your PR, you can merge it, and I'll make blabs pick up the new
   configuration.

* <2017-02-14 Tue> -- Doing Computer: Starting to Pull this All Together
:PROPERTIES:
:EXPORT_FILE_NAME: lesson_03_beginning_development.html
:END:

Okay: we know how to work a terminal. We know how to clone a git repo. Let's
start pulling the pieces together. We'll start with some software development
tools, and their relationship with our computers.

** But first: ~brew~
These instructions assume you've installed python via brew. Here's a basic set
of bash command call-and-responses you should be able to execute:

#+BEGIN_SRC sh
which brew    # Should be something very much like /usr/local/bin/brew
which python  # Should be something like /usr/local/bin/python
which python3 # You'll never guess: /usr/local/bin/python3
which pip     # /usr/local/bin/pip (do you sense a pattern?)
#+END_SRC

** Getting Going: ~virtualenvs~ and ~virtualenvwrapper~
Let's get rocking with two of the very few python packages you always want
installed globally: [[https://virtualenv.readthedocs.org/en/latest/][virtualenv]] and [[https://virtualenvwrapper.readthedocs.org/en/latest/][virtualenvwrapper]]. The installation is done
with ~pip~, and is the easy part:

#+BEGIN_SRC sh
pip install virtualenv virtualenvwrapper
#+END_SRC

But... what are they /for/? What do they /do/? Let's have a motivating example,
shall we?

Imagine you've installed python 3 as the default version of python on your
computer. What's more, you've been noodling around a bunch in the python
interpreter, using the ~requests~ library to do HTTP requests and the
~beautifulsoup~ library to parse the results. You're having a perfectly nice time,
until you decide to contribute to an open source project. You clone it, manually
install a stack of dependencies for it, and... it detonates spectacularly. It
was written for python 2! It uses an antique version of ~requests~ and an even
older version of ~beautifulsoup~! Sturm und drang! Gnashing of teeth! If only
there were a better way to separate your /system/ from a /project/.

You can, perhaps, see where this is going.

~virtualenv~ and ~virtualenvwrapper~ are two indispensable tools for, effectively,
putting your projects in tidy boxes and managing them separately from the rest
of your system. They work through a combination of /environment variables/ and
manipulation of the Linux /path/. Let's talk about what on earth that means.

*** The Environment
So far, we've been considering the Terminal an interface to the file system. But
it's more: the Terminal is, in some sense, very much like the python
interpreter. That is, it's a running instance of a program which interprets
commands and produces output. In this case, the interpreter is a "shell", which
is also the broad family of languages we're now using. By default, OSX systems
use Bourne Again SHell, usually called BASH. There's a small multitude of
others. We wont be discussing them ;-P

When you open a terminal, you are interacting with a shell /session/. Like python,
BASH has a notion of /variables/, many of which are set by default when you start
a session. These variables are part of your /environment/, and are referred to as
/environment variables/.

Remember when I told you your home dir is special to your computer? Here's
another way that shows up: one environment variable set in every BASH session is
called ~HOME~. (By convention, environment variables are always upper case.) We
can view the value of ~HOME~ using two things: a dollar sign, and ~echo~, thus:

#+BEGIN_SRC sh
echo $HOME
#+END_SRC

#+RESULTS:
: /Users/rossdonaldson

Similarly, your user name is sorted in a variable called ~USER~:

#+BEGIN_SRC sh
echo $USER
#+END_SRC

#+RESULTS:
: rossdonaldson

You can see your entire environment all at once using the ~printenv~ command. I'm
not going to put the results of that here for two reasons:

1. The list can be /quite/ long
2. It's not uncommon to store sensitive information, like api keys and
   passwords, in environment variables. I /really/ don't want to accidentally put
   one of those in a public github.

That said: check out ~printenv~ on your own machine!

Now, there's a particular environment variable we particularly care about right
now. You could view it with ~echo~, but we're going to find it's value a different
way: piping and grep.

*** Standard In, Standard Out, Pipes, and Grep
When you type ~echo $HOME~, your home dir appears in your terminal, and then
you're returned to your prompt. Something like this, probably:

#+BEGIN_EXAMPLE
$ echo $HOME
/Users/rossdonaldson
$
#+END_EXAMPLE

What we're seeing is the result of a program, ~echo~, printing the value of a
variable, ~HOME~, to /standard out/. Often written /stdout/, standard out is one of
the three Linux standard streams. (Like many Linux things, the name hearkens
back to a day when computers worked very differently, and is now mostly a
legacy.) stdout equates to, "just stream the results of doing FOO back to
whoever asked me to FOO" -- in this case, us, our terminal, echoing ~HOME~.

Now, what if we want to send that output somewhere /other/ than our terminal? For
instance, we could save it to a file, using the ~>~ operator:

#+BEGIN_SRC sh
mkdir -p /tmp/dev-demo && cd /tmp/dev-demo
printenv > my_env.txt
ls -l
#+END_SRC

#+RESULTS:
: total 8
: -rw-r--r--  1 rossdonaldson  wheel  902 Feb 20 10:05 my_env.txt

The contents of my environment have been written to a file called
my_env.txt. Note that ~>~ means, "take the results of the thing on the left and
make them be the contents of the thing on the right" -- it's a destructive
operation:

#+BEGIN_SRC sh
echo 'no more env here' > my_env.txt
cat my_env.txt
#+END_SRC

#+RESULTS:
: no more env here

For non-destructive addition, you could use ~>>~:

#+BEGIN_SRC sh
echo 'but now there is other stuff so ok?' >> my_env.txt
cat my_env.txt
#+END_SRC

#+RESULTS:
: no more env here
: but now there is other stuff so ok?

For a lark, we could count the lines in this file. To do this, we'll use the
word count program, ~wc~, passing the ~-l~ file to count... lines.

#+BEGIN_SRC sh
wc -l my_env.txt
#+END_SRC

#+RESULTS:
:        2 my_env.txt

Okay, so that's good and useful. But what if we wanted to actually count the
number of variables in our environment? Sure, we could ~printenv~ in to a file and
then ~wc -l~ it, but there's a better way. For this, the operator we want is
Pipe. The pipe operator, ~|~, shares the back-slash key on a stock Mac
keyboard. It means, "take the results of the thing on my left and send them to
the thing on my right". We can now count the number of variables in our
environment without using a file at all:

#+BEGIN_SRC sh
printenv | wc -l
#+END_SRC

#+RESULTS:
:       18

What we're really doing is making use of one of the other three standard
streams: standard input, or /stdin/. Most Linux command-line utilities can operate
on a file *or*, if a file name is omitted, read from stdin. Pipe means, "take the
stdout stream from the thing on the left and feed it to stdin on the
right". (Similarly, ~>~ is, "take stdout from the left and write it to a file on
the right", and ~>>~ is, "take stdout from the left and /append/ it to a file on the
right".)

Okay so counting variables is fine, but let's see something more useful:
~grep~. ~grep~ searches for a pattern in a place, line by line. That place can be a
file, sure -- but more useful is a stream. Let's grep our environment to find
the value of our PATH:

#+BEGIN_SRC sh
printenv | grep PATH
#+END_SRC

#+RESULTS:
: PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/MacGPG2/bin:/Applications/Emacs.app/Contents/MacOS/bin-x86_64-10_9:/Applications/Emacs.app/Contents/MacOS/libexec-x86_64-10_9:/usr/bin:/Users/rossdonaldson/bin:/Users/rossdonaldson/.dotfiles/bin

Blam!

*** The PATH
So what exactly /is/ the ~PATH~, anyhow? First: see how there's all those colons in
there? Let's look at the PATH another way:

#+BEGIN_SRC sh
IFS=":" read -r -a paths <<< "$PATH"

for p in "${paths[@]}"; do echo $p; done
#+END_SRC

#+RESULTS:
#+begin_example
/usr/local/bin
/usr/bin
/bin
/usr/sbin
/sbin
/usr/local/bin
/opt/X11/bin
/usr/local/MacGPG2/bin
/Applications/Emacs.app/Contents/MacOS/bin-x86_64-10_9
/Applications/Emacs.app/Contents/MacOS/libexec-x86_64-10_9
/usr/bin
/Users/rossdonaldson/bin
/Users/rossdonaldson/.dotfiles/bin
#+end_example

The ~PATH~ is a concatenated list of directories, separated by ~:~. The ~PATH~ tells
the shell how to find programs so you can run them. Let's have an example: say
you want to run ~git~. The program ~which~ will tell you a) if a program can be
found by a given name, and b) which program it is, so:

#+BEGIN_SRC sh
which git
#+END_SRC

#+RESULTS:
: /usr/local/bin/git

That was easy. We can confirm there really is a ~git~-named thing in
~/usr/local/bin~ using ~ls~ and ~grep~ and our new Linux-pipe-friend:

#+BEGIN_SRC sh
ls -l /usr/local/bin | grep git
#+END_SRC

#+RESULTS:
#+begin_example
lrwxr-xr-x  1 rossdonaldson  staff      28 Feb  3 10:55 git -> ../Cellar/git/2.11.1/bin/git
lrwxr-xr-x  1 rossdonaldson  staff      45 Feb  3 10:55 git-credential-netrc -> ../Cellar/git/2.11.1/bin/git-credential-netrc
lrwxr-xr-x  1 rossdonaldson  staff      51 Feb  3 10:55 git-credential-osxkeychain -> ../Cellar/git/2.11.1/bin/git-credential-osxkeychain
lrwxr-xr-x  1 rossdonaldson  staff      38 Feb  3 10:55 git-cvsserver -> ../Cellar/git/2.11.1/bin/git-cvsserver
lrwxr-xr-x  1 rossdonaldson  staff      41 Feb  3 10:55 git-receive-pack -> ../Cellar/git/2.11.1/bin/git-receive-pack
lrwxr-xr-x  1 rossdonaldson  staff      34 Feb  3 10:55 git-shell -> ../Cellar/git/2.11.1/bin/git-shell
lrwxr-xr-x  1 rossdonaldson  staff      36 Feb  3 10:55 git-subtree -> ../Cellar/git/2.11.1/bin/git-subtree
lrwxr-xr-x  1 rossdonaldson  staff      43 Feb  3 10:55 git-upload-archive -> ../Cellar/git/2.11.1/bin/git-upload-archive
lrwxr-xr-x  1 rossdonaldson  staff      40 Feb  3 10:55 git-upload-pack -> ../Cellar/git/2.11.1/bin/git-upload-pack
lrwxr-xr-x  1 rossdonaldson  staff      29 Feb  3 10:55 gitk -> ../Cellar/git/2.11.1/bin/gitk
#+end_example

That's a lot of stuff with ~git~ in the name! And one of them is exactly what we
were looking for: ~git~ itsown self[fn:1].

The thing to understand about the ~PATH~ is that your shell searches it /in order/,
looking for a program that matches what you've asked for.

*** Bringing it back to ~virtualenvs~

A ~virtualenvironment~ works like this: a user-specified version of python (with a
matching installation of pip) is installed in to a directory. Then, when the
~virtualenv~ is /activated/, the ~PATH~ is altered: ~virtualenv~ temporarily appends its
install directory to the front of the ~PATH~. This means that when you ask for
~python~, you'll get the ~virtualenv~-specified version, and any packages installed
with pip will be of a specified version. Let's see how this works in practice.

First: which python is my default, system python?

#+BEGIN_SRC sh
which python
#+END_SRC

#+RESULTS:
: /usr/local/bin/python

Great. Now let's make a ~virtualenv~:

#+BEGIN_SRC sh
cd /tmp && mkdir venv-demo && cd venv-demo
virtualenv .
#+END_SRC

#+RESULTS:
: New python executable in /private/tmp/bin/python2.7
: Not overwriting existing python script /private/tmp/bin/python (you must use /private/tmp/bin/python2.7)
: Installing setuptools, pip, wheel...done.

Great! Our new ~virtualenv~ is done. We activate it by sourcing a shell script
called ~activate~ in a dir called ~bin~ (the traditional name for a directory of
~binaries~, or executables):

#+BEGIN_SRC sh
source bin/activate
which python
#+END_SRC

#+RESULTS:

Et voila! We're now using a totally different python. ~virtualenv~:
activated. Now, when we install packages with pip, they'll be specific to this
environment, not affecting our global state or other projects. ~virtualenv~ has
appended its own directories to the front of the ~PATH~:

#+BEGIN_SRC sh
source bin/activate
echo $PATH
#+END_SRC

#+RESULTS:

When we ~source~ the ~activate~ script, we gain a new command: ~deactivate~. It --
brace yourself for this -- deactivates the ~virtualenv~:

#+BEGIN_SRC sh
deactivate
#+END_SRC

#+RESULTS:

*** Managing ~virtualenvs~
~virtualenvs~ are good news; they help us solve the otherwise maddening problem of
dependencies and python versions. But, now we have a new problem. Consider the
contents of our project directory now:

#+BEGIN_SRC sh
ls -la
#+END_SRC

#+RESULTS:
#+begin_example
total 1016
drwxr-xr-x  17 rossdonaldson  staff     578 Feb 20 10:03 .
drwxr-xr-x  15 rossdonaldson  staff     510 Feb 16 11:33 ..
drwxr-xr-x  14 rossdonaldson  staff     476 Feb 20 10:03 .git
-rw-r--r--   1 rossdonaldson  staff      33 Jan 31 18:58 .gitignore
-rw-r--r--   1 rossdonaldson  staff     154 Jan 24 14:40 README.markdown
-rw-r--r--   1 rossdonaldson  staff   35290 Jan 31 18:47 lesson_01_development_environment.html
-rw-r--r--@  1 rossdonaldson  staff   14177 Jan 31 19:03 lesson_01_development_environment.markdown
-rw-r--r--   1 rossdonaldson  staff   69754 Feb  8 12:21 lesson_02_git.html
-rw-r--r--   1 rossdonaldson  staff   37061 Feb  8 12:22 lesson_02_git.markdown
-rw-r--r--   1 rossdonaldson  staff   21662 Feb 20 09:30 lesson_03_beginning_development.markdown
-rw-r--r--   1 rossdonaldson  staff    9740 Jan 24 14:40 lesson_04_ssh_plain_text.markdown
-rw-r--r--   1 rossdonaldson  staff   43493 Jan 24 14:40 lesson_05_http_and_html.markdown
-rw-r--r--   1 rossdonaldson  staff   36247 Jan 24 14:40 lesson_06_databases_part_one.markdown
-rw-r--r--   1 rossdonaldson  staff   22496 Jan 30 19:09 lesson_07_databases_part_two.markdown
-rw-r--r--   1 rossdonaldson  staff  190224 Feb 20 10:03 master_file.org
-rw-r--r--   1 rossdonaldson  staff      53 Feb 20 10:05 my_env.txt
-rwxr-xr-x   1 rossdonaldson  staff     119 Jan 31 18:55 pandoc.sh
#+end_example

~bin~ is a directory of ~virtualenv~ stuff. ~lib~ is full of python executables. ~lib~
is where pip installs packages into the ~virtualenv~ itself. Convinced this is a
mess yet? No? Consider:

#+BEGIN_SRC sh
git init
git status
#+END_SRC

#+RESULTS:
#+begin_example
Reinitialized existing Git repository in /Users/rossdonaldson/Code/personal/2016_sds_lesson_notes/.git/
On branch 2017_is_real_now
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   lesson_03_beginning_development.markdown
    modified:   master_file.org

Untracked files:
  (use "git add <file>..." to include in what will be committed)

    my_env.txt

no changes added to commit (use "git add" and/or "git commit -a")
#+end_example

You do /not/ want any of that nonsense in ~git~. One solution is a good ~.gitignore~,
which wouldn't be bad, but is easy to get wrong. Instead, consider: when we
activate a ~virtualenv~, it appends its own binaries to the front of the
~PATH~. What's stopping us from storing those binaries /somewhere else all
together/? The answer is: absolutely nothing. ~virtualenvwrapper~ is a tool that
helps us do exactly this, while providing a very clean interface.

*** Setting up and using ~virtualenvwrapper~
~virtualenvwrapper~ gives you the ability to set a single, configurable location
into which all your ~virtualenvs~ will be installed. ~virtualenvwrapper~ uses an
environment variable to configure where it does its installation, so the first
thing to do is to get that set.

We've already checked the value of environment variables. There are two common
ways of setting them: per session and globally.

To set a variable only in your current BASH session, use the ~export~ command:
#+BEGIN_SRC sh
export PLABBER='I am the plabber'
echo $PLABBER
#+END_SRC

#+RESULTS:
: I am the plabber

This variable will vanish if you exit or reload your terminal, so it's a handy
way to test something and a bad way to keep it.


More commonly, we want new environment variables to persist. To do this, we use
the same syntax as per-session, but instead of typing it in to the terminal, we
write it in to a configuration file. BASH recognizes several configuration
files; on OSX, users typically edit their ~.bash_profile~. For instance:

#+BEGIN_SRC sh
echo "export PLABBER='I am the plabber'" >> ~/.bash_profile
#+END_SRC

#+RESULTS:

Now ~PLABBER~ is a permanent member of my profile. Glee.

In any case: back to ~virtualenvwrapper~, which looks for an environment variable
called ~WORKON_HOME~. Mine is set in my ~.bash_profile~, like this:

#+BEGIN_SRC sh
export WORKON_HOME=~/.python_venvs
#+END_SRC

#+RESULTS:

While you're editing your ~.bash_profile~, ~virtualenvwrapper~ has one other thing
that needs doing: it provides a file that needs to be /sourced/ -- that is, read
in to the current environment, much like ~virtualenv~'s ~activate~ script -- so that
we gain its full power. Add this, too:

#+BEGIN_SRC sh
source /usr/local/bin/virtualenvwrapper.sh
#+END_SRC

#+RESULTS:

Now, things get good.

*** A quick tour of ~virtualenvwrapper~
#+BEGIN_SRC sh
source /usr/local/bin/virtualenvwrapper.sh
#+END_SRC

You now have access to a set of marvelously useful commands with excellent
properties. For instance: imagine we've made a new directory and we're setting
up a python project in it:

#+BEGIN_SRC sh
cd /tmp && mkdir -p venv/venv-wrapper-demo && cd venv/venv-wrapper-demo
git init
echo "print 'hello world'" > hello.py
ls -la
#+END_SRC

#+RESULTS:
: Reinitialized existing Git repository in /private/tmp/venv/venv-wrapper-demo/.git/
: total 8
: drwxr-xr-x  4 rossdonaldson  wheel  136 Feb 20 09:27 .
: drwxr-xr-x  3 rossdonaldson  wheel  102 Feb 20 09:27 ..
: drwxr-xr-x  9 rossdonaldson  wheel  306 Feb 20 10:05 .git
: -rw-r--r--  1 rossdonaldson  wheel   20 Feb 20 10:05 hello.py

We decide it's time for a ~virtualenv~. Instead of using the ~virtualenv~ command
directly, we use ~mkvirtualenv~:

#+BEGIN_SRC sh
mkvirtualenv venv-demo
#+END_SRC

#+RESULTS:
: New python executable in /Users/rossdonaldson/.python_virtualenvs/venv-demo/bin/python2.7
: Not overwriting existing python script /Users/rossdonaldson/.python_virtualenvs/venv-demo/bin/python (you must use /Users/rossdonaldson/.python_virtualenvs/venv-demo/bin/python2.7)
: Installing setuptools, pip, wheel...done.

Now, in our project dir we see:

#+BEGIN_SRC sh
ls -la
#+END_SRC

#+RESULTS:
#+begin_example
total 1016
drwxr-xr-x  17 rossdonaldson  staff     578 Feb 20 10:03 .
drwxr-xr-x  15 rossdonaldson  staff     510 Feb 16 11:33 ..
drwxr-xr-x  14 rossdonaldson  staff     476 Feb 20 10:05 .git
-rw-r--r--   1 rossdonaldson  staff      33 Jan 31 18:58 .gitignore
-rw-r--r--   1 rossdonaldson  staff     154 Jan 24 14:40 README.markdown
-rw-r--r--   1 rossdonaldson  staff   35290 Jan 31 18:47 lesson_01_development_environment.html
-rw-r--r--@  1 rossdonaldson  staff   14177 Jan 31 19:03 lesson_01_development_environment.markdown
-rw-r--r--   1 rossdonaldson  staff   69754 Feb  8 12:21 lesson_02_git.html
-rw-r--r--   1 rossdonaldson  staff   37061 Feb  8 12:22 lesson_02_git.markdown
-rw-r--r--   1 rossdonaldson  staff   21662 Feb 20 09:30 lesson_03_beginning_development.markdown
-rw-r--r--   1 rossdonaldson  staff    9740 Jan 24 14:40 lesson_04_ssh_plain_text.markdown
-rw-r--r--   1 rossdonaldson  staff   43493 Jan 24 14:40 lesson_05_http_and_html.markdown
-rw-r--r--   1 rossdonaldson  staff   36247 Jan 24 14:40 lesson_06_databases_part_one.markdown
-rw-r--r--   1 rossdonaldson  staff   22496 Jan 30 19:09 lesson_07_databases_part_two.markdown
-rw-r--r--   1 rossdonaldson  staff  190224 Feb 20 10:03 master_file.org
-rw-r--r--   1 rossdonaldson  staff      53 Feb 20 10:05 my_env.txt
-rwxr-xr-x   1 rossdonaldson  staff     119 Jan 31 18:55 pandoc.sh
#+end_example

Nothing different at all! The ~virtualenv~ has been created in an entirely
different location. We can list our available ~virtualenvs~ like so:

#+BEGIN_SRC sh
lsvirtualenv -b #-b is "brief mode"; output can be long
#+END_SRC

#+RESULTS:

We can activate a ~virtualenv~ with the ~workon~ command:

#+BEGIN_SRC sh
workon venv-demo
#+END_SRC

#+RESULTS:

And we can still deactivate with ~deactivate~.

** Starting Development
:PROPERTIES:
:header-args: :results verbatim :exports both :session venv
:END:

Step one: clone the repo
#+BEGIN_SRC sh
cd /tmp && mkdir l03 && cd l03
git clone git@github.com:Gastove/slackbort.git
#+END_SRC

#+RESULTS:
: mkdir: l03: File exists
: fatal: destination path 'slackbort' already exists and is not an empty directory.

Step two: ~cd~ in to that directory and have a look around:
#+BEGIN_SRC sh
cd slackbort && ls -la
#+END_SRC

#+RESULTS:
: total 32
: drwxr-xr-x   8 rossdonaldson  wheel   272 Feb 20 09:30 .
: drwxrwxrwt  30 root           wheel  1020 Feb 20 10:05 ..
: drwxr-xr-x  12 rossdonaldson  wheel   408 Feb 20 09:30 .git
: -rw-r--r--   1 rossdonaldson  wheel    10 Feb 20 09:30 .gitignore
: -rw-r--r--   1 rossdonaldson  wheel   145 Feb 20 09:30 README.md
: -rw-r--r--   1 rossdonaldson  wheel    46 Feb 20 09:30 auth.cfg.tpl
: -rw-r--r--   1 rossdonaldson  wheel    30 Feb 20 09:30 requirements.txt
: drwxr-xr-x   4 rossdonaldson  wheel   136 Feb 20 09:30 slackbort

Notice "requirements.txt" -- that's an extremely handy file. By convention, it
contains the output of the pip command ~freeze~, which prints all installed
packages with their versions from the current environment. Conveniently, pip
prints this information in a format it can also read, using the ~-r <filename>~
argument to ~pip install~. Let's make ~virtualenv~ and get the deps for this project
installed:

#+BEGIN_SRC sh
# mkvirtualenv l03-slackbort
echo "$PATH"
#+END_SRC

#+RESULTS:
:
: /Users/rossdonaldson/.python_virtualenvs/venv-demo/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/MacGPG2/bin:/Applications/Emacs.app/Contents/MacOS/bin-x86_64-10_9:/Applications/Emacs.app/Contents/MacOS/libexec-x86_64-10_9:/usr/bin:/Users/rossdonaldson/bin:/Users/rossdonaldson/.dotfiles/bin

#+BEGIN_SRC sh
pip install -r requirements.txt
#+END_SRC

#+RESULTS:
: Requirement already satisfied: requests==2.9.1 in /Users/rossdonaldson/.python_virtualenvs/venv-demo/lib/python2.7/site-packages (from -r requirements.txt (line 1))
: Collecting wheel==0.29.0 (from -r requirements.txt (line 2))
:   Using cached wheel-0.29.0-py2.py3-none-any.whl
: Installing collected packages: wheel
:   Found existing installation: wheel 0.30.0a0
:     Uninstalling wheel-0.30.0a0:
:       Successfully uninstalled wheel-0.30.0a0
: Successfully installed wheel-0.29.0

(I'm mostly redacting the output from that command, but it should end with
something much like this:)
#+begin_example
Successfully installed requests-2.9.1 wheel-0.29.0
#+end_example

For the sake of thoroughness, we can now compare ~pip freeze~ and
~requirements.txt~:

#+BEGIN_SRC sh
pip freeze
#+END_SRC

#+RESULTS:
: appdirs==1.4.0
: packaging==16.8
: pyparsing==2.1.10
: requests==2.9.1
: six==1.10.0

#+BEGIN_EXAMPLE
requests==2.9.1
wheel==0.29.0
#+END_EXAMPLE

#+BEGIN_SRC sh
cat requirements.txt
#+END_SRC

#+RESULTS:
: requests==2.9.1
: wheel==0.29.0

Perfect.

** Homework
Make sure brew, python2.7, python3, virtualenv, and virtualenvwrapper are all
installed and work! You can test this with Slackbort. If you have time and
interest, play around with Slackbort!

* <2017-02-21 Tue> -- Text and SSH Keys
:PROPERTIES:
:EXPORT_FILE_NAME: lesson_04_ssh_plain_text.markdown
:END:

** First, a couple points

*** Text versus Everything Else
Let's look at bits of two different files:

#+BEGIN_SRC sh
cat ~/.bashrc | head
#+END_SRC

#+RESULTS:
: #!/bin/bash
:
: # bashrc
:
: [ -n "$PS1" ] && source ~/.bash_profile
:
: ### Added by the Heroku Toolbelt
: export PATH="/usr/local/heroku/bin:$PATH"

Okay, that looks just fine. I recognize a few words! "bin" and "bash" -- both
fine words, good good. Now, what about something else? Note: for a few reasons,
the output of the following commands are not being spliced in to this document
(they actually confuse the hell out of both text editors and git). So, to follow
along at home, find files with the equivalent extension. First, how about a JPEG:

#+BEGIN_SRC sh :exports code
cat ~/Dropbox/Photos/grumpycat_wsj_headcut.jpg | head
#+END_SRC

Well, uh that's pretty... not... word-looking. How about an MP3:

#+BEGIN_SRC sh :exports code
  cat ~/Dropbox/eMusic/Doomtree/All\ Hands/1.\ Final\ Boss.mp3 | head
#+END_SRC

/Hnnnnnnnng/. Yeah okay. We aren't getting anywhere, fast. What on earth is going
on?

The answer is: we're looking at /binary/ data. Binary files are encoded in the
language of your computer -- which makes sense, right? Reading a JPEG makes
maybe a little more sense than reading an MP3, but only just barely. We have
specialized programs to open MP3s and JPEGs -- software like iTunes and Preview
that know how to interpret the binary data. When we attempt to read them, our
computers take a wild stab at turning the binary information in each file in to
text, and... it's not pretty, or useful.

We're accustomed to this. For most of us, before we code, we write documents in
Microsoft Word. I wonder:

#+BEGIN_SRC sh :exports code
cat ~/Dropbox/gradschool/capstone/Modus\ Cooperandi/Donaldson,\ Ross\ _\ ModusCooperandiCapstoneProjectCharter.doc | head
#+END_SRC

See this is a weird conceptual gotcha: Word documents /are not plain text/. We
think of them as being full of words, but they are actually a proprietary binary
format -- barely words at all. We need a special program -- Word -- to open a
~.doc~ or ~.docx~.

And here's the inverse: if a file is plain text we can open it
with... anything, almost. You can't open a Word document in Sublime, but you
could open your ~.bash_profile~ in Word if you felt so inclined[fn:3]. This is why
text editors are so, so, so important -- in the world of code, source files are
pretty much always /just text/. So are all the configuration files that control
your laptop. So are all the configuration files that control every Linux and
Unix computer in the world.

** SSH Keys
*** What the Crap is SSH?
SSH -- short for Secure Shell, is a protocol by which two computers can
exchange information. Sometimes, we connect to another computer "over" SSH,
allowing us to use that computer through the terminal on our own "local"
computer. At other times, a service "uses" SSH to move other data -- say, a file
-- from one computer to another. SSH really is pretty damn secure; it's also
used in a /lot/ of different places, making it an awfully useful tool to have set
up.

There's a whole heck of a lot we could get in to on the topic of how SSH
works. Frankly, we're just going to skip most of it. The important thing to know
right now is this: SSH requires you to make a set of SSH /keys/. You'll have two
keys, a "public" key and a "private" key. For instance:

#+BEGIN_SRC sh
ls -la ~/.ssh
#+END_SRC

#+RESULTS:
: total 32
: drwx------   5 gastove  staff   170 Nov 15  2013 .
: drwxr-xr-x+ 69 gastove  staff  2346 Mar  4 19:58 ..
: -rw-------   1 gastove  staff  1679 Nov 15  2013 id_rsa
: -rw-r--r--   1 gastove  staff   405 Nov 15  2013 id_rsa.pub
: -rw-r--r--   1 gastove  staff  4440 Apr  6  2015 known_hosts

~id_rsa~ is my private key; ~id_rsa.pub~ is my public key. (~known_hosts~ tracks places
I've SSHed to, and is otherwise not germane right now.)

The public key is precisely that -- public. You don't want to share your public
SSH key by posting it on your web site or tweeting it -- not /that/ public. But
for instance: if you join the tech sector, one of the very first things you're
likely to do is get a work laptop, generate work SSH keys, and send your public
key to someone on the Ops team. They'll then put that SSH key on every computer
you're allowed SSH access to.

Here's a gross oversimplification of how this works: your private key can be
used to encrypt a message which your public key can then decrypt. In this way,
your keys can be used for your computer to say, "hi it's me!", and for a server
to then say, "yes, I can decrypt your message correctly, therefore I know it is
you."

Here at Reed, we'll use SSH keys for Github access, as well as for access to
virtual machines in the Reed stack, if you ever need such a thing.

*** Makin' SSH Keys

So how do we do this? Great question! Good news: it's easy. Open yer terminal
and execute like so:

#+BEGIN_SRC sh :eval never :exports code
ssh-keygen -t rsa -b 4096 -C <your email address>
#+END_SRC

~-t~ tells keygen to make you an "RSA" SSH key.[fn:2] ~-b 4096~ makes a 4,095-bit
long key (longer keys are more secure). ~-C~ adds a comment, in this case your
email address.

You'll receive a prompt asking you to "Enter a file in which to save the
key". Hit Enter to accept the default, which will be ~$HOME/.ssh/id_rsa~ and
~id_rsa.pub~.

Next, a point of security: you'll be prompted for a password. The password will
lock your ssh key, and you wont be able to use your key without entering the
password. This is vastly more secure; it's also optional.

Next... you're done! Good job.

*** What to do with your SSH Keys
Here's a great one: go to github.com and log in. In the upper-right-hand corner
of the screen is a tiny little representation of your avatar; click the arrow
next to that, then hit /Settings/. There's a dialogue on the left side of the
screen: SSH Keys. Click that.

Hit "New SSH Key". Osnap: you're asked to give it a name, and then there's
just... a text box.

Remember out discussion of plain text data? Your ~id_rsa.pub~ is also /just text/ --
by which I mean, "literally only". In your home directory, do:

#+BEGIN_SRC sh
cat ~/.ssh/id_rsa.pub
#+END_SRC

You'll see something a lot like:

#+RESULTS:
: ssh-rsa AAAGB3NzaC1yc2EAAAADAQABAAABAQDQ1fvnMbYDN1nm8X8KZY3d/sPG14L9nngvDZXU2BbDm+zMLkc5arWelqpY6bLxKhlo0p5lDbD/LXZL8QwUE527TVe2eZvORXrv8GbbDINVG+qXCSxmCBGv2nnMakijsy/WsUGScPBXgaYsKzcrvKO+ZdjwBbZ+Eqkl7085aorQsST2PKAE81jCJx5hpI/E/5NdUMeC1vi7GnEn+wROh4TU/fQIR8r3kTAoSbyph7l/8D0UE4Nwm3xtEGjL7PJPn2x4u8X8gV3IQvHLn1uJiaAHxRjYC1vOJDAClnyU0N9OJcN9xkGo1CImyzFTZw0UGqN2uBoqjl/djvG2HOe0yTLd gastove@apparatus.local

That's your public key. (No, that's /not/ my public key. It's a demo. Don't put
your public key in a git repo. Not /that/ public.)

Anywho: notice that's it's just a string of letters and numbers -- that's
it. Copy paste that whole thing in to the box on Github. Hit "Add SSH
Key". Done! You win! Good job.

Note that you can have an effectively unlimited number of SSH keys. This is part
of the beauty of them -- I have separate keys for my work laptop and my work
desktop, so security can be managed on them separately. For instance: if my work
laptop is stolen, we can revoke only its keys and I can generate new ones,
leaving my desktop untouched.

*** Using SSH with git: a brief lesson in URIs

If you go to [[https://github.com/Gastove/slackbort][the Slackbort repo on Github]], you'll see at the top there's a box
with either "HTTPS" or "SSH" in it, followed by some text -- either
~https://github.com/Gastove/slackbort.git~ or
~git@github.com:Gastove/slackbort.git~. The first one runs over HTTPS; the second
goes over SSH.

While we tend to call these "URLs" (Uniform Resource Locator), the proper name
is "URI" -- Uniform Resource /Identifier/. A URI is more general, and has this
form:

#+BEGIN_EXAMPLE
 scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]
#+END_EXAMPLE

In practice, the ~scheme~ is often omitted, provided by context. For instance:
when we type something like, ~/Users/gastove/.bash_profile~, that is /also/ a
URI. It omits the ~scheme~, which is ~file://~. Modern web browsers often elide the
scheme as well, but we're more accustomed to seeing ~http~ or ~https~. Some of us
have probably used ~ftp://~.

So: a URI that begins with ~git@github.com~ is telling git to try and access the
~github.com~ domain with user ~git~; it then looks for a repo, which traditionally
has the form ~<username or organization>/<repo name>.git~. This is, it should be
noted, just the way Github is set up; git URIs very often have a form more
like, for instance, those at my work:
~ssh://git@atlassian.prod.urbanairship.com:222/reports/hubble.git~.

** Homework
1. Make sure your dev env is set up! Can you do /everything/ from the last two
   homeworks? I hope so!
2. Write me an email answering these questions:
   1. Will you be in Portland over Spring Break?
   2. If so, would you like to work?
   3. If so, would you enjoy having one or two SDS workshops of 2-5 hours in
      length?
3. Start customizing your terminal. You can bill me for as many customizations
   as you feel like making, but at minimum do the following:
   1. Make a dir in your home directory called ~bin~. Add it to your ~$PATH~. Verify
      it works by doing the following:
      1. Make a file in ~bin~ called ~boop~.
      2. Put these two lines in the file:
         #+BEGIN_SRC sh
         #!/usr/bin/env bash
         echo 'boop!'
         #+END_SRC
      3. In the terminal, in your home dir, run the command, ~chmod a+x bin/boop~
         (this tells your terminal that ~boop~ is an executable).
      4. Type ~boop~ in your terminal. If you see a ~boop!~, you win!
   2. Alter your prompt to show the full path of your current working directory.
      Yes, there are websites that will generate super fancy prompts for you.
      You can do this if you want, but 1) bill me honestly, and 2) it defeats
      the point of the exercise if you don't understand what you're doing. If
      you have a website make you a fancy prompt, spend a few hours picking it
      apart! Research what it's doing. Learning about the dang thing so you can
      poke it yourself.
   3. Turn on colorization for the output of ~ls~ if it isn't already.

* <2017-02-28 Tue> -- Web Applications: What do?
:PROPERTIES:
:EXPORT_FILE_NAME: lesson_05_web_applications.md
:END:

#+name: postproc-rm-ctrlm
#+BEGIN_SRC python :var to_clean='default' :results output :exports results
print to_clean.decode('utf-8', 'ignore')
#+END_SRC

*** The General Idea: Web Servers
You would like a Web Page to Appear on the Internet -- /but how?/ What is the
mechanism by which we arrive at a Web Page being On the Internet? What if that
web page is "interactive" -- what then?

The answer is a web server -- a piece of software that runs on a computer and
provides (that is, /serves/) content using a communication protocol called HTTP
(sometimes HTTPS). In this way, two computers -- say, your computer and a server
-- can have a conversation roughly like this:

- Your Computer: Hey Server! Gimme thewebpage.com!
- The Server: You got it! Here it is.

Today we're going to expand the above exchange -- make it considerably more
detailed and accurate. Note that our goal is a working mental model, *not* an
exhaustive representation of how the modern internet functions. We'll be eliding
a number of details, though I'll try to be very clear about which ones and
when. This section will be considerably heavier on the "want to learn more?
click here!" links than our previous topics.

Ready? Here we go!

*** A note about ~cURL~, ~sed~, and newline characters
~cURL~ (more commonly ~curl~) is a command-line utility for interacting with The
Internet. I'll be using it here to get raw content from the internet. You'll see
a certain amount of the ~-i~ (include headers) and ~-I~ (only the headers) flags.

~curl~ is veryvery powerful, and also a little arcane. It's not completely
ubiquitous, but it's close -- so I'm using it here. Personally, I prefer
[[https://github.com/jkbrzt/httpie][httpie]], but you do you.

Also appearing: ~sed~, the Unix Stream EDitor. ~sed~ allows you to take a stream of
text -- for instance, returned from ~cat~ -- and make a change to each line,
frequently using this syntax:

#+BEGIN_EXAMPLE
sed -e "s/value to find/value to replace it with/g"
#+END_EXAMPLE

For instance, imagine we have a text file like:
#+BEGIN_SRC sh :results silent
echo "fizz" >> /tmp/fizz.txt
echo "fizz" >> /tmp/fizz.txt
echo "fizz" >> /tmp/fizz.txt
#+END_SRC

We could change all the "fizz"s to "buzz"s so:
#+BEGIN_SRC sh :exports both
cat /tmp/fizz.txt | sed -e "s/fizz/buzz/"
#+END_SRC

#+RESULTS:
: buzz
: buzz
: buzz

~sed~ has absolutely nothing to do with ~curl~, or even HTTP. ~sed~ is frequently used
to clean up the output of other commands; in this document, I'll use it to clean
up /newline characters/. A newline character tells your computer -- you'll never
guess -- that you've hit the end of one line and it's time to start a new
one. But: there is no one universal newline character. On Unix, the newline
character is ~\n~. On some windows machines, it's ~\r\n~. And on some Windows and
DOS machines, it's a character usually written ~^M~ (control-m).

So. When you see in the code examples, for instance:

#+BEGIN_SRC sh :eval never
curl -i http://www.google.com | sed -e "s/^M//"
#+END_SRC

That means, "take the output from ~curl~ and use ~sed~ to remove the non-Unix line
endings", which makes these documents nicer to work with on *nix machines.

*Note*: in these notes, I've taken steps to strip all the nonsense out
already. You might see Nonsense out in the world in places it isn't visibly
present in these notes.

*** HTTP: Hypertext Transfer Protocol
Boy is there a lot we /could/ say about HTTP. There's a whole lot to be said about
how it works (much of which I do not, frankly, know). There's even more to be
said about how it developed. HTTP is an amazing study in how the /specification/
of a piece of technology and the implementation of it might entirely diverge
once the world at large is involved. For instance: HTTP 1.1 was specified in
[[https://tools.ietf.org/html/rfc2068][1997]], was obsolete by [[https://tools.ietf.org/html/rfc2616][1999]], and is still the most common version of the protocol
in use today. In 2017. Just... let that sink in. The format of HTTP messages was
defined in 1982. The specifying [[https://tools.ietf.org/html/rfc822][RFC]] is still titled, /Standard for the Format of
ARPA Internet Text Messages/.

Good news: unless you want to deal with HTTP professionally -- as in, after Reed
-- you don't especially need to get your head around a *lot* of the stuff you
/could/ know about HTTP. Here's the stuff you do need to grok:

**** HTTP Messages
An HTTP Message consists of a set of /headers/ followed by a body, thus:

#+BEGIN_SRC sh :post postproc-rm-ctrlm(to_clean=*this*)
curl -i http://www.google.com
#+END_SRC

#+RESULTS:
#+begin_example

HTTP/1.1 200 OK
Date: Mon, 04 Apr 2016 03:44:32 GMT
Expires: -1
Cache-Control: private, max-age=0
Content-Type: text/html; charset=ISO-8859-1
P3P: CP="This is not a P3P policy! See https://www.google.com/support/accounts/answer/151657?hl=en for more info."
Server: gws
X-XSS-Protection: 1; mode=block
X-Frame-Options: SAMEORIGIN
Set-Cookie: NID=78=Rqq9sWJygp3oemwPUMi054zP9rHVHP9OWVv7OpNE2XP-h0VT1nnDEcQLGkdJGdxBlw_XFWKEZzX38NOzxxfKDmqtnRNctUcRVSQc6iTfYYcctxiJCNUFSnQ0CtfV8c14VGaaAE8ge0cEUeI; expires=Tue, 04-Oct-2016 03:44:32 GMT; path=/; domain=.google.com; HttpOnly
Accept-Ranges: none
Vary: Accept-Encoding
Transfer-Encoding: chunked

<!doctype html><html itemscope="" itemtype="http://schema.org/WebPage" lang="en"><head><meta content="Search the world's information, including webpages, images, videos and more. Google has many special features to help you find exactly what you're looking for." name="description"><meta content="noodp" name="robots"><meta content="text/html; charset=UTF-8" http-equiv="Content-Type"><meta content="/images/branding/googleg/1x/googleg_standard_color_128dp.png" itemprop="image"><title>Google</title><script>(function(){window.google={kEI:'IOMBV7L9F6ajjgScjYfgDA',kEXPI:'1350531,3700335,3700388,3700389,3700393,4029815,4031109,4032678,4033307,4036509,4036527,4038012,4039268,4042784,4042792,4043492,4045841,4046304,4048347,4049549,4049557,4051159,4051558,4052304,4053261,4054284,4054552,4055202,4055917,4055945,4056038,4057069,4057169,4057316,4057739,4057836,4058085,4058327,4058330,4058337,4059767,4060681,4060726,4061000,4061089,4061125,4061155,4061181,4061252,4061300,4061552,4061782,4061925,4062067,4062333,4062407,4062535,4062628,4062645,4062680,4062706,4063117,4063361,4063362,4063366,4063575,4063744,4063745,4063779,4063929,4064239,8300273,8300307,8300310,8502094,8502946,8503512,8503585,8503647,8503811,8503926,8503928,8503932,8503934,8504030,8504107,8504111,10200083',authuser:0,kscs:'c9c918f0_24'};google.kHL='en';})();(function(){google.lc=[];google.li=0;google.getEI=function(a){for(var b;a&&(!a.getAttribute||!(b=a.getAttribute("eid")));)a=a.parentNode;return b||google.kEI};google.getLEI=function(a){for(var b=null;a&&(!a.getAttribute||!(b=a.getAttribute("leid")));)a=a.parentNode;return b};google.https=function(){return"https:"==window.location.protocol};google.ml=function(){return null};google.wl=function(a,b){try{google.ml(Error(a),!1,b)}catch(d){}};google.time=function(){return(new Date).getTime()};google.log=function(a,b,d,e,g){a=google.logUrl(a,b,d,e,g);if(""!=a){b=new Image;var c=google.lc,f=google.li;c[f]=b;b.onerror=b.onload=b.onabort=function(){delete c[f]};window.google&&window.google.vel&&window.google.vel.lu&&window.google.vel.lu(a);b.src=a;google.li=f+1}};google.logUrl=function(a,b,d,e,g){var c="",f=google.ls||"";if(!d&&-1==b.search("&ei=")){var h=google.getEI(e),c="&ei="+h;-1==b.search("&lei=")&&((e=google.getLEI(e))?c+="&lei="+e:h!=google.kEI&&(c+="&lei="+google.kEI))}a=d||"/"+(g||"gen_204")+"?atyp=i&ct="+a+"&cad="+b+c+f+"&zx="+google.time();/^http:/i.test(a)&&google.https()&&(google.ml(Error("a"),!1,{src:a,glmm:1}),a="");return a};google.y={};google.x=function(a,b){google.y[a.id]=[a,b];return!1};google.load=function(a,b,d){google.x({id:a+k++},function(){google.load(a,b,d)})};var k=0;})();var _gjwl=location;function _gjuc(){var a=_gjwl.href.indexOf("#");if(0<=a&&(a=_gjwl.href.substring(a),0<a.indexOf("&q=")||0<=a.indexOf("#q="))&&(a=a.substring(1),-1==a.indexOf("#"))){for(var d=0;d<a.length;){var b=d;"&"==a.charAt(b)&&++b;var c=a.indexOf("&",b);-1==c&&(c=a.length);b=a.substring(b,c);if(0==b.indexOf("fp="))a=a.substring(0,d)+a.substring(c,a.length),c=d;else if("cad=h"==b)return 0;d=c}_gjwl.href="/search?"+a+"&cad=h";return 1}return 0}
function _gjh(){!_gjuc()&&window.google&&google.x&&google.x({id:"GJH"},function(){google.nav&&google.nav.gjh&&google.nav.gjh()})};window._gjh&&_gjh();</script><style>#gbar,#guser{font-size:13px;padding-top:1px !important;}#gbar{height:22px}#guser{padding-bottom:7px !important;text-align:right}.gbh,.gbd{border-top:1px solid #c9d7f1;font-size:1px}.gbh{height:0;position:absolute;top:24px;width:100%}@media all{.gb1{height:22px;margin-right:.5em;vertical-align:top}#gbar{float:left}}a.gb1,a.gb4{text-decoration:underline !important}a.gb1,a.gb4{color:#00c !important}.gbi .gb4{color:#dd8e27 !important}.gbf .gb4{color:#900 !important}
</style><style>body,td,a,p,.h{font-family:arial,sans-serif}body{margin:0;overflow-y:scroll}#gog{padding:3px 8px 0}td{line-height:.8em}.gac_m td{line-height:17px}form{margin-bottom:20px}.h{color:#36c}.q{color:#00c}.ts td{padding:0}.ts{border-collapse:collapse}em{font-weight:bold;font-style:normal}.lst{height:25px;width:496px}.gsfi,.lst{font:18px arial,sans-serif}.gsfs{font:17px arial,sans-serif}.ds{display:inline-box;display:inline-block;margin:3px 0 4px;margin-left:4px}input{font-family:inherit}a.gb1,a.gb2,a.gb3,a.gb4{color:#11c !important}body{background:#fff;color:black}a{color:#11c;text-decoration:none}a:hover,a:active{text-decoration:underline}.fl a{color:#36c}a:visited{color:#551a8b}a.gb1,a.gb4{text-decoration:underline}a.gb3:hover{text-decoration:none}#ghead a.gb2:hover{color:#fff !important}.sblc{padding-top:5px}.sblc a{display:block;margin:2px 0;margin-left:13px;font-size:11px}.lsbb{background:#eee;border:solid 1px;border-color:#ccc #999 #999 #ccc;height:30px}.lsbb{display:block}.ftl,#fll a{display:inline-block;margin:0 12px}.lsb{background:url(/images/nav_logo229.png) 0 -261px repeat-x;border:none;color:#000;cursor:pointer;height:30px;margin:0;outline:0;font:15px arial,sans-serif;vertical-align:top}.lsb:active{background:#ccc}.lst:focus{outline:none}</style><script></script><link href="/images/branding/product/ico/googleg_lodp.ico" rel="shortcut icon"></head><body bgcolor="#fff"><script>(function(){var src='/images/nav_logo229.png';var iesg=false;document.body.onload = function(){window.n && window.n();if (document.images){new Image().src=src;}
if (!iesg){document.f&&document.f.q.focus();document.gbqf&&document.gbqf.q.focus();}
}
})();</script><div id="mngb">    <div id=gbar><nobr><b class=gb1>Search</b> <a class=gb1 href="http://www.google.com/imghp?hl=en&tab=wi">Images</a> <a class=gb1 href="http://maps.google.com/maps?hl=en&tab=wl">Maps</a> <a class=gb1 href="https://play.google.com/?hl=en&tab=w8">Play</a> <a class=gb1 href="http://www.youtube.com/?tab=w1">YouTube</a> <a class=gb1 href="http://news.google.com/nwshp?hl=en&tab=wn">News</a> <a class=gb1 href="https://mail.google.com/mail/?tab=wm">Gmail</a> <a class=gb1 href="https://drive.google.com/?tab=wo">Drive</a> <a class=gb1 style="text-decoration:none" href="https://www.google.com/intl/en/options/"><u>More</u> &raquo;</a></nobr></div><div id=guser width=100%><nobr><span id=gbn class=gbi></span><span id=gbf class=gbf></span><span id=gbe></span><a href="http://www.google.com/history/optout?hl=en" class=gb4>Web History</a> | <a  href="/preferences?hl=en" class=gb4>Settings</a> | <a target=_top id=gb_70 href="https://accounts.google.com/ServiceLogin?hl=en&passive=true&continue=http://www.google.com/" class=gb4>Sign in</a></nobr></div><div class=gbh style=left:0></div><div class=gbh style=right:0></div>    </div><center><span id="prt" style="display:block"> <div><style>.pmoabs{background-color:#fff;border:1px solid #E5E5E5;color:#666;font-size:13px;padding-bottom:20px;position:absolute;right:2px;top:3px;z-index:986}#pmolnk{border-radius:2px;-moz-border-radius:2px;-webkit-border-radius:2px}.kd-button-submit{border:1px solid #3079ed;background-color:#4d90fe;background-image:-webkit-gradient(linear,left top,left bottom,from(#4d90fe),to(#4787ed));background-image:-webkit-linear-gradient(top,#4d90fe,#4787ed);background-image:-moz-linear-gradient(top,#4d90fe,#4787ed);background-image:-ms-linear-gradient(top,#4d90fe,#4787ed);background-image:-o-linear-gradient(top,#4d90fe,#4787ed);background-image:linear-gradient(top,#4d90fe,#4787ed);filter:progid:DXImageTransform.Microsoft.gradient(startColorStr='#4d90fe',EndColorStr='#4787ed')}.kd-button-submit:hover{border:1px solid #2f5bb7;background-color:#357ae8;background-image:-webkit-gradient(linear,left top,left bottom,from(#4d90fe),to(#357ae8));background-image:-webkit-linear-gradient(top,#4d90fe,#357ae8);background-image:-moz-linear-gradient(top,#4d90fe,#357ae8);background-image:-ms-linear-gradient(top,#4d90fe,#357ae8);background-image:-o-linear-gradient(top,#4d90fe,#357ae8);background-image:linear-gradient(top,#4d90fe,#357ae8);filter:progid:DXImageTransform.Microsoft.gradient(startColorStr='#4d90fe',EndColorStr='#357ae8')}.kd-button-submit:active{-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,0.3);-moz-box-shadow:inset 0 1px 2px rgba(0,0,0,0.3);box-shadow:inset 0 1px 2px rgba(0,0,0,0.3)}#pmolnk a{color:#fff;display:inline-block;font-weight:bold;padding:5px 20px;text-decoration:none;white-space:nowrap}.xbtn{color:#999;cursor:pointer;font-size:23px;line-height:5px;padding-top:5px}.padi{padding:0 8px 0 10px}.padt{padding:5px 20px 0 0;color:#444}.pads{text-align:left;max-width:200px}</style> <div class="pmoabs" id="pmocntr2" style="behavior:url(#default#userdata);display:none"> <table border="0"> <tr> <td colspan="2"> <div class="xbtn" onclick="google.promos&&google.promos.toast&& google.promos.toast.cpc()" style="float:right">&times;</div> </td> </tr> <tr> <td class="padi" rowspan="2"> <img src="/images/icons/product/chrome-48.png"> </td> <td class="pads">Try a fast, secure browser with updates built in.</td> </tr> <tr> <td class="padt"> <div class="kd-button-submit" id="pmolnk"> <a href="/chrome/browser/?hl=en&amp;brand=CHNG&amp;utm_source=en-hpp&amp;utm_medium=hpp&amp;utm_campaign=en" onclick="google.promos&&google.promos.toast&& google.promos.toast.cl()">Yes, get Chrome now</a> </div> </td> </tr> </table> </div> <script type="text/javascript">(function(){var a={v:{}};a.v.mb=50;a.v.kb=10;a.v.La="body";a.v.Nb=!0;a.v.Qb=function(b,c){var d=a.v.Db();a.v.Fb(d,b,c);a.v.Rb(d);a.v.Nb&&a.v.Ob(d)};a.v.Rb=function(b){(b=a.v.Na(b))&&0<b.forms.length&&b.forms[0].submit()};a.v.Db=function(){var b=document.createElement("iframe");b.height=0;b.width=0;b.style.overflow="hidden";b.style.top=b.style.left="-100px";b.style.position="absolute";document.body.appendChild(b);return b};a.v.Na=function(b){return b.contentDocument||b.contentWindow.document};a.v.Fb=function(b,c,d){b=a.v.Na(b);b.open();d=["<",a.v.La,'><form method=POST action="',d,'">'];for(var e in c)c.hasOwnProperty(e)&&d.push('<textarea name="',e,'">',c[e],"</textarea>");d.push("</form></",a.v.La,">");b.write(d.join(""));b.close()};a.v.Pa=function(b,c){c>a.v.kb?google&&google.ml&&google.ml(Error("ogcdr"),!1,{cause:"timeout"}):b.contentWindow?a.v.Pb(b):window.setTimeout(function(){a.v.Pa(b,c+1)},a.v.mb)};a.v.Pb=function(b){document.body.removeChild(b)};a.v.Ob=function(b){a.v.Bb(b,"load",function(){a.v.Pa(b,0)})};a.v.Bb=function(b,c,d){b.addEventListener?b.addEventListener(c,d,!1):b.attachEvent&&b.attachEvent("on"+c,d)};var m={Vb:0,$:1,ka:2,va:5,Ub:6};a.s={};a.s.ya={Ya:"i",ta:"d",$a:"l"};a.s.U={Aa:"0",ma:"1"};a.s.Ba={wa:1,ta:2,ra:3};a.s.S={Sa:"a",Wa:"g",W:"c",vb:"u",ub:"t",Aa:"p",lb:"pid",Ua:"eid",wb:"at"};a.s.Za=window.location.protocol+"//www.google.com/_/og/promos/";a.s.Va="g";a.s.yb="z";a.s.Fa=function(b,c,d,e){var f=null;switch(c){case m.$:f=window.gbar.up.gpd(b,d,!0);break;case m.va:f=window.gbar.up.gcc(e)}return null==f?0:parseInt(f,10)};a.s.Jb=function(b,c,d){return c==m.$?null!=window.gbar.up.gpd(b,d,!0):!1};a.s.Ca=function(b,c,d,e,f,h,k,l){var g={};g[a.s.S.Aa]=b;g[a.s.S.Wa]=c;g[a.s.S.Sa]=d;g[a.s.S.wb]=e;g[a.s.S.Ua]=f;g[a.s.S.lb]=1;k&&(g[a.s.S.W]=k);l&&(g[a.s.S.vb]=l);if(h)g[a.s.S.ub]=h;else return google.ml(Error("knu"),!1,{cause:"Token is not found"}),null;return g};a.s.Ia=function(b,c,d){if(b){var e=c?a.s.Va:a.s.yb;c&&d&&(e+="?authuser="+d);a.v.Qb(b,a.s.Za+e)}};a.s.Eb=function(b,c,d,e,f,h,k){b=a.s.Ca(c,b,a.s.ya.ta,a.s.Ba.ta,d,f,null,e);a.s.Ia(b,h,k)};a.s.Hb=function(b,c,d,e,f,h,k){b=a.s.Ca(c,b,a.s.ya.Ya,a.s.Ba.wa,d,f,e,null);a.s.Ia(b,h,k)};a.s.Mb=function(b,c,d,e,f,h,k,l,g,n){switch(c){case m.va:window.gbar.up.dpc(e,f);break;case m.$:window.gbar.up.spd(b,d,1,!0);break;case m.ka:g=g||!1,l=l||"",h=h||0,k=k||a.s.U.ma,n=n||0,a.s.Eb(e,h,k,f,l,g,n)}};a.s.Kb=function(b,c,d,e,f){return c==m.$?0<d&&a.s.Fa(b,c,e,f)>=d:!1};a.s.Gb=function(b,c,d,e,f,h,k,l,g,n){switch(c){case m.va:window.gbar.up.iic(e,f);break;case m.$:c=a.s.Fa(b,c,d,e)+1;window.gbar.up.spd(b,d,c.toString(),!0);break;case m.ka:g=g||!1,l=l||"",h=h||0,k=k||a.s.U.Aa,n=n||0,a.s.Hb(e,h,k,1,l,g,n)}};a.s.Lb=function(b,c,d,e,f,h){b=a.s.Ca(c,b,a.s.ya.$a,a.s.Ba.ra,d,e,null,null);a.s.Ia(b,f,h)};var p={Sb:"a",Wb:"l",Tb:"c",Ta:"d",ra:"h",wa:"i",mc:"n",ma:"x",jc:"ma",kc:"mc",lc:"mi",Xb:"pa",Yb:"pc",$b:"pi",dc:"pn",ac:"px",Zb:"pd",nc:"gpa",sc:"gpi",tc:"gpn",uc:"gpx",qc:"gpd"};a.o={};a.o.R={ab:"hplogo",tb:"pmocntr2"};a.o.U={rb:"0",ma:"1",Ra:"2"};a.o.w=document.getElementById(a.o.R.tb);a.o.Xa=16;a.o.nb=2;a.o.qb=20;google.promos=google.promos||{};google.promos.toast=google.promos.toast||{};a.o.qa=function(b){a.o.w&&(a.o.w.style.display=b?"":"none",a.o.w.parentNode&&(a.o.w.parentNode.style.position=b?"relative":""))};a.o.Qa=function(b){try{if(a.o.w&&b&&b.es&&b.es.m){var c=window.gbar.rtl(document.body)?"left":"right";a.o.w.style[c]=b.es.m-a.o.Xa+a.o.nb+"px";a.o.w.style.top=a.o.qb+"px"}}catch(d){google.ml(d,!1,{cause:a.o.T+"_PT"})}};google.promos.toast.cl=function(){try{a.o.Da==m.ka&&a.s.Lb(a.o.Ga,a.o.V,a.o.U.Ra,a.o.Ka,a.o.Ha,a.o.Ja),window.gbar.up.sl(a.o.V,a.o.T,p.ra,a.o.Ea(),1)}catch(b){google.ml(b,!1,{cause:a.o.T+"_CL"})}};google.promos.toast.cpc=function(){try{a.o.w&&(a.o.qa(!1),a.s.Mb(a.o.w,a.o.Da,a.o.R.Ma,a.o.Ga,a.o.Cb,a.o.V,a.o.U.ma,a.o.Ka,a.o.Ha,a.o.Ja),window.gbar.up.sl(a.o.V,a.o.T,p.Ta,a.o.Ea(),1))}catch(b){google.ml(b,!1,{cause:a.o.T+"_CPC"})}};a.o.Oa=function(){try{if(a.o.w){var b=276,c=document.getElementById(a.o.R.ab);c&&(b=Math.max(b,c.offsetWidth));var d=parseInt(a.o.w.style.right,10)||0;a.o.w.style.visibility=2*(a.o.w.offsetWidth+d)+b>document.body.clientWidth?"hidden":""}}catch(e){google.ml(e,!1,{cause:a.o.T+"_HOSW"})}};a.o.Ab=function(){var b=["gpd","spd","aeh","sl"];if(!window.gbar||!window.gbar.up)return!1;for(var c=0,d;d=b[c];c++)if(!(d in window.gbar.up))return!1;return!0};a.o.Ib=function(){return a.o.w.currentStyle&&"absolute"!=a.o.w.currentStyle.position};google.promos.toast.init=function(b,c,d,e,f,h,k,l,g,n,q,r){try{if(!a.o.Ab())google.ml(Error("apa"),!1,{cause:a.o.T+"_INIT"});else if(a.o.w)if(e==m.ka&&!l==!g)google.ml(Error("tku"),!1,{cause:"zwieback: "+g+", gaia: "+l}),a.o.qa(!1);else if(a.o.R.W="toast_count_"+c+(q?"_"+q:""),a.o.R.Ma="toast_dp_"+c+(r?"_"+r:""),a.o.T=d,a.o.V=b,a.o.Da=e,a.o.Ga=c,a.o.Cb=f,a.o.Ka=l?l:g,a.o.Ha=!!l,a.o.Ja=k,a.s.Jb(a.o.w,e,a.o.R.Ma,c)||a.s.Kb(a.o.w,e,h,a.o.R.W,c)||a.o.Ib())a.o.qa(!1);else{a.s.Gb(a.o.w,e,a.o.R.W,c,f,a.o.V,a.o.U.rb,a.o.Ka,a.o.Ha,a.o.Ja);if(!n){try{window.gbar.up.aeh(window,"resize",a.o.Oa)}catch(t){}window.lol=a.o.Oa;window.gbar.elr&&a.o.Qa(window.gbar.elr());window.gbar.elc&&window.gbar.elc(a.o.Qa);a.o.qa(!0)}window.gbar.up.sl(a.o.V,a.o.T,p.wa,a.o.Ea())}}catch(t){google.ml(t,!1,{cause:a.o.T+"_INIT"})}};a.o.Ea=function(){var b=a.s.Fa(a.o.w,a.o.Da,a.o.R.W,a.o.Ga);return"ic="+b};})();</script> <script type="text/javascript">(function(){var sourceWebappPromoID=144002;var sourceWebappGroupID=5062030;var payloadType=5;var cookieMaxAgeSec=2592000;var dismissalType=5;var impressionCap=30;var gaiaXsrfToken='';var zwbkXsrfToken='';var kansasDismissalEnabled=false;var sessionIndex=0;var invisible=false;window.gbar&&gbar.up&&gbar.up.r&&gbar.up.r(payloadType,function(show){if (show){google.promos.toast.init(sourceWebappPromoID,sourceWebappGroupID,payloadType,dismissalType,cookieMaxAgeSec,impressionCap,sessionIndex,gaiaXsrfToken,zwbkXsrfToken,invisible,'0612');}
});})();</script> </div> </span><br clear="all" id="lgpd"><div id="lga"><img alt="Google" height="92" src="/images/branding/googlelogo/1x/googlelogo_white_background_color_272x92dp.png" style="padding:28px 0 14px" width="272" id="hplogo" onload="window.lol&&lol()"><br><br></div><form action="/search" name="f"><table cellpadding="0" cellspacing="0"><tr valign="top"><td width="25%">&nbsp;</td><td align="center" nowrap=""><input name="ie" value="ISO-8859-1" type="hidden"><input value="en" name="hl" type="hidden"><input name="source" type="hidden" value="hp"><input name="biw" type="hidden"><input name="bih" type="hidden"><div class="ds" style="height:32px;margin:4px 0"><input style="color:#000;margin:0;padding:5px 8px 0 6px;vertical-align:top" autocomplete="off" class="lst" value="" title="Google Search" maxlength="2048" name="q" size="57"></div><br style="line-height:0"><span class="ds"><span class="lsbb"><input class="lsb" value="Google Search" name="btnG" type="submit"></span></span><span class="ds"><span class="lsbb"><input class="lsb" value="I'm Feeling Lucky" name="btnI" onclick="if(this.form.q.value)this.checked=1; else top.location='/doodles/'" type="submit"></span></span></td><td class="fl sblc" align="left" nowrap="" width="25%"><a href="/advanced_search?hl=en&amp;authuser=0">Advanced search</a><a href="/language_tools?hl=en&amp;authuser=0">Language tools</a></td></tr></table><input id="gbv" name="gbv" type="hidden" value="1"></form><div id="gac_scont"></div><div style="font-size:83%;min-height:3.5em"><br></div><span id="footer"><div style="font-size:10pt"><div style="margin:19px auto;text-align:center" id="fll"><a href="/intl/en/ads/">AdvertisingPrograms</a><a href="/services/">Business Solutions</a><a href="https://plus.google.com/116899029375914044550" rel="publisher">+Google</a><a href="/intl/en/about.html">About Google</a></div></div><p style="color:#767676;font-size:8pt">&copy; 2016 - <a href="/intl/en/policies/privacy/">Privacy</a> - <a href="/intl/en/policies/terms/">Terms</a></p></span></center><script>(function(){window.google.cdo={height:0,width:0};(function(){var a=window.innerWidth,b=window.innerHeight;if(!a||!b)var c=window.document,d="CSS1Compat"==c.compatMode?c.documentElement:c.body,a=d.clientWidth,b=d.clientHeight;a&&b&&(a!=google.cdo.width||b!=google.cdo.height)&&google.log("","","/client_204?&atyp=i&biw="+a+"&bih="+b+"&ei="+google.kEI);})();})();</script><div id="xjsd"></div><div id="xjsi"><script>(function(){function c(b){window.setTimeout(function(){var a=document.createElement("script");a.src=b;document.getElementById("xjsd").appendChild(a)},0)}google.dljp=function(b,a){google.xjsu=b;c(a)};google.dlj=c;})();(function(){window.google.xjsrm=[];})();if(google.y)google.y.first=[];if(!google.xjs){window._=window._||{};window._._DumpException=function(e){throw e};if(google.timers&&google.timers.load.t){google.timers.load.t.xjsls=new Date().getTime();}google.dljp('/xjs/_/js/k\x3dxjs.hp.en_US.JYNNhRR1vUI.O/m\x3dsb_he,d/rt\x3dj/d\x3d1/t\x3dzcms/rs\x3dACT90oGKeyuixW2vug5z6_hvD7hYKD06QA','/xjs/_/js/k\x3dxjs.hp.en_US.JYNNhRR1vUI.O/m\x3dsb_he,d/rt\x3dj/d\x3d1/t\x3dzcms/rs\x3dACT90oGKeyuixW2vug5z6_hvD7hYKD06QA');google.xjs=1;}google.pmc={"sb_he":{"agen":true,"cgen":true,"client":"heirloom-hp","dh":true,"dhqt":true,"ds":"","fl":true,"host":"google.com","isbh":28,"jam":0,"jsonp":true,"msgs":{"cibl":"Clear Search","dym":"Did you mean:","lcky":"I\u0026#39;m Feeling Lucky","lml":"Learn more","oskt":"Input tools","psrc":"This search was removed from your \u003Ca href=\"/history\"\u003EWeb History\u003C/a\u003E","psrl":"Remove","sbit":"Search by image","srch":"Google Search"},"ovr":{},"pq":"","refpd":true,"rfs":[],"scd":10,"sce":5,"stok":"DmuqqxacBOdA600a5KqHLmYcEIE"},"d":{}};google.y.first.push(function(){if(google.med){google.med('init');google.initHistory();google.med('history');}});if(google.j&&google.j.en&&google.j.xi){window.setTimeout(google.j.xi,0);}
</script></div></body></html>
#+end_example

So that's the homepage for Google. Don't worry too much about what the headers
/are/ right now; the important part is that there's a whole bunch of 'em, then an
empty line, then then some HTML. This is a standard HTTP Message -- headers,
newline, body. Boom.

**** Request / Response
HTTP interactions have two parts: a /request/ and a /response/. This is about what
it sounds like:

- <REQUEST> Your Computer: Hey Server! Gimme thewebpage.com!
- <RESPONSE> The Server: You got it! Here it is.

HTTP uses the same message format for both requests and responses. From here,
we'll refer to the requestor by a more accurate, general name: the /client/. The
client requests information of the server, then renders it for you, the user, to
interact with.

**** Status Codes
Let's take a simpler example: the server that serves my personal website. I'll
show /only/ the headers with ~curl~'s ~-I~ flag:

#+BEGIN_SRC sh :post postproc-rm-ctrlm(to_clean=*this*)
curl -I http://thermador.herokuapp.com
#+END_SRC

#+RESULTS:
: HTTP/1.1 200 OK
: Connection: keep-alive
: Date: Mon, 04 Apr 2016 03:47:02 GMT
: Content-Type: text/plain
: Server: Jetty(7.6.1.v20120215)
: Via: 1.1 vegur

That first like is the one we care about: ~HTTP/1.1 200 OK~. ~HTTP/1.1~ is our HTTP
version, low excitement there, but ~200 OK~ is our /status code/. Status codes are
how the server tells us about the success (or failure) of our request. There
are quite a few status codes, and a well-setup web server can give fairly
precise information about an HTTP request using them. [[https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html][Here's the full list]]; for
now, some common codes are:

- 200 OK: our favorite. 200 is the "everything worked and is great!" status code
- 403 Forbidden: you are not authorized to access whatever it was you were
  trying to get
- 404 Not Found: the thing you asked for isn't there
- 500 Internal Server Error: the server is borked, somehow

It's worth realizing that the correct implementation of HTTP status codes is not
a solved problem. For instance, what do you do if a request is valid *and* you are
authorized to make it *and* the resource is found, *but* there is a problem in your
request? For instance, if have a correctly implemented Slack bot with a valid
token and you try to open a direct message channel with a non-existent user,
Slack will return something like:

#+BEGIN_EXAMPLE js
HTTP/1.1 200 OK

{
  'ok': 'false',
  'error': 'user_not_found'
}
#+END_EXAMPLE

They return a ~200 OK~, because your request is valid, but then the response body
specifies ~ok: false~, and tells you the user wasn't found. Neat? Neat. Point is:
there are usual practices and things one expects, and then there's The Internet.

**** More About Headers
#+BEGIN_SRC sh :post postproc-rm-ctrlm(to_clean=*this*)
curl -I http://www.google.com
#+END_SRC

#+RESULTS:
#+begin_example
HTTP/1.1 200 OK
Date: Tue, 22 Mar 2016 15:45:40 GMT
Expires: -1
Cache-Control: private, max-age=0
Content-Type: text/html; charset=ISO-8859-1
P3P: CP="This is not a P3P policy! See https://www.google.com/support/accounts/answer/151657?hl=en for more info."
Server: gws
X-XSS-Protection: 1; mode=block
X-Frame-Options: SAMEORIGIN
Set-Cookie: NID=77=qWBx91uHeVVvp3EV6odPIQvAZbKMjZEmASMk035DnnDC_Qh7d0iTfxVsO9K4_P9nIdvStYOQeDzR3UuHDB7g2KcF8Uj8AcmqCokoMVCM3GAu4fIfrgaKIgzEy7loY2regHcC-r0ZMLzZTQ; expires=Wed, 21-Sep-2016 15:45:40 GMT; path=/; domain=.google.com; HttpOnly
Transfer-Encoding: chunked
Accept-Ranges: none
Vary: Accept-Encoding

#+end_example

We can think of headers, /generally/ as sets of key-value pairs, which you can see
up above -- the key ~Expires~ has the value ~-1~, for instance. In this way, a
client and the responding HTTP server convey useful information to each
other. ~Content-Type~, for instance, is how the server tells the client, "here is
what I'm going to give you" -- plain text, or JSON, or a PNG or a JavaScript
application. A client might set authorization information as a header, so the
server knows the client is allowed access to a given URL. Cookies are passed
back and forth in headers, allowing a site to (on the benign end of the
spectrum) color links you've already clicked.


**** HTTP Verbs and Resources
So: we know that clients and servers exchange messages using the same
format. We've seen status codes in an HTTP response; for a request, the
equivalent piece of the puzzle is a /verb/ and a /resource/. Let's use ~curl -v~ to
see what our /request/ looks like -- what the server is actually responding to:
#+BEGIN_EXAMPLE
curl -v http://thermador.herokuapp.com
 Rebuilt URL to: http://thermador.herokuapp.com/
   Trying 50.17.220.70...
 Connected to thermador.herokuapp.com (50.17.220.70) port 80 (#0)
> GET / HTTP/1.1
> Host: thermador.herokuapp.com
> User-Agent: curl/7.43.0
> Accept: */*
>
< HTTP/1.1 200 OK
< Connection: close
< Date: Tue, 22 Mar 2016 17:30:04 GMT
< Content-Type: text/plain;charset=ISO-8859-1
< Server: Jetty(7.6.1.v20120215)
< Via: 1.1 vegur
<
 Closing connection 0
["Hello" :from Heroku]
#+END_EXAMPLE

The line we care about right now is: ~GET / HTTP/1.1~. And really, only the first
two things -- ~HTTP/1.1~ specifies the version of HTTP our request is speaking,
which is useful but not particularly interesting (it'll almost always be
1.1). Let's focus on ~GET /~.

~/~ is our /resource/. In much the same way ~/~ represents the root of the file system
on our Linux computers, here ~/~ is the root of the website we're viewing. Now,
several fun bits of obfuscation on the modern web: notice that in my ~curl~
request, I didn't specify I wanted ~/~ -- ~curl~ automatically "rebuilt" the URL to
include it. Remember the format of URIs? As a reminder, it's this:

#+BEGIN_EXAMPLE
 scheme:[//[user:password@]host[:port]][/]path[?query][#fragment]
#+END_EXAMPLE

A URL (Uniform Resource /Locator/) is a more specific form of URI in which the
scheme[fn:5] is always specified. For instance, in the URL
~http://www.google.com~, ~http~ is the /scheme/. User and password are omitted most of
the time on the Internet-at-large, so they're absent; ~www.google.com~ is the
/host/.  What ~curl~ has implicitly added is the ~/~ that indicates the root resource at
the given host. (Modern web browsers make this all even more opaque by eliding
more and more of a given URL -- for instance, we typically don't see the scheme
or the port in a URL, even if we specify them.)

There's a second tier of obfuscation: by convention, specifying a resource
either as ~/~ or ending in ~/~ means, "give me a document named index.html at
location ~/~". So we ask for ~www.google.com~, which implicitly means
~www.google.com/~. A web server can return whatever it likes for the root
resource; in the absence of anything else, by convention a page called
~index.html~ is returned. So the URL we've gotten might /actually/ be
~wwww.google.com/index.html~, while the browser just shows us that we're at
~www.google.com~. Great.

~GET~ is an HTTP /verb/ (technically /methods/, but /verb/ is common parlance and I find
it to be clearer). It describes what action we want to take on the thing we're
requesting. ~GET~ is far and away the most common -- it means, "just give me the
thing I asked for, maybe with some parameters". (~GET~ is so common that it's the
default for tools like ~curl~, though other verbs can be specified.) There are
others; the other two you're likely to come across are:

- ~POST~ -- "Upload this information to this resource"; commonly used in web forms.
- ~DELETE~ -- Delete whatever is described by this resource

**** Updating our Client/Server Conversation
Our conversation between client and server could now be fleshed out to look like
this:

- <REQUEST> Your Computer: Hey thewebpage.com! I'd like to ~GET~ the root
     resource at ~/~, please!
- <RESPONSE> The Server: 200 OK you got it! Here's a ~text/html~ response body
     for my root ~index.html~. Also can you hang on to this cookie for me? Send it
     back to me next time so I can keep track of you a little.

**** But Wait, There's More: IP Addresses, ~localhost~, ports, and a touch of DNS
Okay, here's a fun one: there is no such thing as ~www.google.com~. Or, more
precisely: there is no /one/ thing that is ~www.google.com~, and none of the things
that serve ~www.google.com~ URLs have any idea what this "google dot com" nonsense
is. ~www.google.com~ is a /host name/, which servers don't speak. Instead, servers
speak /Internet Protocol Addresses/ -- IP addresses for short. Bad news: the
systems that handle IP addresses are monstrously complicated. Good news: while
it's good to know those systems are there and what their names are, you don't
need to know much at all about how they actually work.

The system that maps host names to IP Addresses is called a /Domain Name System/,
or DNS. Here's a gross oversimplification of how this works:

- You, the User: Computer, bring me www.google.com
- Computer: Great. Do I know the IP address of a DNS server? *checks* Yes, I
     do. Hey DNS Server!  What the hell is www.google.com?
- DNS Server: I'm not sure, but I know a DNS Server who does. Talk to Google's
     DNS Server -- have an IP address.
- Computer : Hokay. Hey Google's DNS Server. What the hell is www.google.com?
- Google's DNS Server : Oh, it's this -- have an IP Address.

So: DNS is a hierarchical system by which a computer can talk to a general
lookup service and reach more specific lookup services until it can talk to a
specific server that can fulfill its request. *Whew*. That is more than enough DNS
for our purposes.

I bring all of this up in part because we need to talk about a special
hostanme/IP Address combo: ~localhost~. ~localhost~, which on Macs has the default
IP address of 127.0.0.1, is your computers way to refer to itself. When you run
a web server on your laptop for local development, the /host/ you'll specify in
your URL is ~localhost~.

A cool true fact:

Desperately want to know more about DNS? Start with Monica Dinculescu's [[http://meowni.ca/posts/go-cat-dns-go/][Cat DNS]]
-- the DNS server that resolves everything to cats.

**** One Last Thing: Public vs. Private
Most often, when we say "on the Internet", we mean we'll be
serving content /publicly/ -- available to the world at large -- but there's
nothing about HTTP that requires it to be public. I can, for example, start an
HTTP server on my laptop, accessibly only to web browsers also on my
computer. Businesses often create a variety of flavors of Walled Garden for
themselves, in which a thing might be "on the Internet", but not available to
the public at large. A Virtual Private Network -- usually just VPN -- is a
common approach to this. Real Talk, VPNs are too big a topic for us to get in
to, but the extra-short version goes like this: a VPN allows a set of computers to
behave as though they are all on the same private network while being connected
to the public internet. This is done (again, a gross simplification) by
encrypting communication between members of the network. Wanna be on the VPN?
You'll need a password or key, and a client. Anywho, [[https://en.wikipedia.org/wiki/Virtual_private_network][here's a lot more about
VPNs]].

You should know that you /can/ serve content to the Public Internet from your
laptop. You almost certainly don't want to do this. Beware of any bug fix or
problem solving suggestion that suggests you serve your content on ~0.0.0.0~ --
that means, "respond to requests from the public internet" and it's very likely
not what you're trying to do.

**** Let's check in with that computer/server conversation again

So now, with DNS and a sense of the basics of HTTP, our conversation looks like this:


- You, the User: Computer, bring me thewebpage.com
- Computer: Great. Do I know the IP address of a DNS server? *checks* Yes, I
     do. Hey DNS Server!  What the hell is thewebpage.com?
- DNS Server: I'm not sure, but I know a DNS Server who does. Talk to the
     server at this IP Address.
- Computer: Hokay. Hey next DNS Server. What the hell is thewebpage.com?
- Next DNS Server : Oh, it's this -- have an IP Addres.
- Computer: Great. Hey thewebpage.com! I'd like to ~GET~ the root
     resource at ~/~, please!
- The Server: 200 OK you got it! Here's a ~text/html~ response body for my root
     ~index.html~. Also can you hang on to this cookie for me? Send it back to me
     next time so I can keep track of you a little.
- Computer: Great. Hey the User: here is some rendered HTML.

Now. A /lot/ of how that last bit goes is actually a function of the /architecture/
of the web application in question. So:

*** What the crap is "architecture"
A shorter, clearer way to frame this is, "how is your application built?" What
are the pieces? Is there a database? What is the client like? How do you scale
your app for traffic? Now: this is a whole buuuuunch of questions, and there are
a lot we aren't going to get to just yet. For now, we're going to ignore the
computer that runs your code and only talk about the code, which will have one
or both of these components:

- A Web Server: some flavor of code you've written that responds to HTTP
     requests with HTTP/JavaScript/images/etc.
- A Client: Probably almost entirely JavaScript; might talk to a Server,
     rendering results. Might be the entire deal, for sufficiently simple apps.

You might also have a database! We're gonna start talking about them next
week. Right now, what you need to know is that a database stores stuff, in a
durable way, for repeat access and manipulation.

*** Yes OK Good let's look at a web app
[[https://github.com/Gastove/http-demo][Here's a demo web app!]] We'll be working our way through the pieces. You can
clone and virtualenv it, in the traditional manner.

Turn on yer virtualenv and run this thing with:

#+BEGIN_SRC python :eval never
python http-demo
#+END_SRC

If it works, you should see a little bit of logging in your terminal. You should
also be able to go to http://localhost:5000 in your web browser of choice and see a
tiny little message. Wee!

*** So what's going on here?
There's now a little Python web server running on your computer. It's host is
~localhost~ (127.0.0.1, as you'll recall), and its port is 5000. (When we develop
locally, we almost always have to specify a port; when we use the Internet at
Large we almost never do.) You'll notice you'll get the same web page if you ask
for localhost:5000, localhost:5000/, or localhost:5000/index.html.

Inside ~http-demo~ is a method that listens for ~/~ or ~/index.html~, and responds by
"serving static HTML". /Static/ here means, "unchanging" -- the opposite of
/dynamic/, which we'll define in just a few more paragraphs. Look in ~static/html~;
you'll see a file named ~index.html~. Its contents are precisely identical to what
you'll see in your web browser if you inspect the source of the page you're
seeing.

In Flask, at least, your methods barely have to do anything at all. Go to
~localhost:5000/minimal~; those words are the only words in the corresponding
method in ~http-demo~. Flask adds just a /touch/ of wrapping HTML, and it appears in
the browser. Neat.

It turns out that when we talk about serving static files, we're almost never
talking about serving pure HTML files. More commonly, we'll talk about /static
assets/, and what we'll be referring to is content like images and CSS (we'll be
discussing what CSS is Soon). If you make a directory inside ~static~ called ~gifs~,
and put a gif in there, you can now access it by name at
~localhost:5000/gifs/<gif_name>~. Neat? Neat.

Now let's head to http://localhost:5000/helloworld. It's got... slightly more to
it! (Very, very slightly.) In fact, it can do a trick. Try
http://localhost:5000/helloworld/ + your name
(http://localhost:5000/helloworld/Ross, for instance). Neat, eh?

The ~helloworld~ resource is returning HTML, but it's doing a handy trick called
/server-side rendering/. It works like this: there is a template called
~hello.html~, which uses a templating system called Jinja. When you ask for
~helloworld/Ross~, for instance, the /Ross/ part of the URL is captured as a
variable. Flask then loads and /renders/ the ~hello.html~ template, which creates
the HTML that's then sent back to your browser.

Here's another way this can be used: head to http://localhost:5000/form. Pick a
beverage and hit ~Yar~. Now there's a result! M A G I C. Okay, more template
rendering -- in this case, ~form~ is a static page (not a template) that uses ~POST~
to pass data from itself to the ~yousaid~ resource, which renders a template.

*** So where does JavaScript fit in?
Terrific question. This demo doesn't currently account for JavaScript, because
there's a /lot/ JS can do. This gets us back to the slowly-expanding idea of
Architecture. See, right now, ~http-demo~ is an entirely server-side
application. A little Flask app serves rendered HTML to your browser /and that's
pretty much it/. These pages are still basically static -- they arrive at the
browser fully formed and with very litter interactivity, save for what HTML
itself provides (forms, for instance).

We could change this by adding a little JavaScript. HTML pages can define a
~script~ tag, which will cause that page to load in, well, a script (almost always
JavaScript). Our app can serve JS scripts just like any other static asset, and
now our page can have a little interactivity -- maybe a little navigation menu,
say. Fundamentally, all the action still really happens on the server, but with
JS we can program in the browser and Do More. HTML is what you can /see/; JS is
really what you can /do/. (It will accomplish this task, almost always, by
creating either HTML or SVG images, or by modifying CSS.)

But there's another option: make a /client out of pure JavaScript/. My personal
web site works like this. There are, in effect, /two/ HTTP servers. One is the
server-side application, which is written in Clojure, and has routes like
http://thermador.herokuapp.com/api/page/about -- which you can go to in your
browser. Looks... pretty weird, right? Not super useful.

But then you head to http://www.gastove.com, and you see a Real Thing. This is
the /second/ HTTP server, which really actually only serves one thing -- a
JavaScript application. When you click on links in that application, JavaScript
intercepts the routes, parses them, and then asks the server for content. This
is called a /Single Page Application/ -- the only "page" in my client is an
index.html that loads JavaScript, and then JS does /everything
else/. Specifically, it communicates with my server using a paradigm called REST
(REpresentational State Transfer) -- the JS client says, "hey, I need the pages
of this site!", and the Server responds with a JSON blob describing all of them,
which the JS then turns in to HTML.

As you might apprehend, this can get complex in a hurry.

*** Homework
Okay, it's time to start tinkering!

1. Install the `http-demo` app and run it locally.
2. Read over the source code.
3. Start reading about [[http://jinja.pocoo.org/docs/2.9/][jinja2]]
4. Start changing things! See if they break, and how.
5. See if you can add a few new routes! What about a new template?
6. For the bold, try adding basic CSS!

* <2017-03-07 Tue> -- Welcome to Databases
:PROPERTIES:
:EXPORT_FILE_NAME: lesson_06_databases_part_one.md
:END:

Okay, this is a topic I love. Databases! Just say it with me. /Databases/. So
good. Day-tuh-bace. /Yes/.

We're going to focus particularly on /relational databases/, though I'll mention a
few other kinds. We'll do some theory, and then we'll learn some SQL. We'll be
working with Postgres as our database of choice.

** Why Database?
Databases give us a lot of tools: the ability to ask very precise questions
about a body of data; the ability to aggregate a body of data; guarantees about
the correctness of data. We get tools for asserting what shape a certain kind of
data should take. We get tools for managing default values, null data, and
backups. We get controls for concurrent access, and for access management. It's
a pretty sweet deal. (Also, two of the best relational databases -- PostgreSQL
and MySQL, are open source and free as songs.)

Databases give us a lot to love, but they aren't always the perfect solution to
a problem. Here's a set of guidelines:

If you are only 1 person; the data will only ever be accessed by one person at
once, manually, use Microsoft Access, Microsoft Excel, Filemaker Pro --
something far lighter weight than setting up a DB and an application to access
it with.

Use a database if:
- The number of simultaneous users of a data store is greater than one, or
- There is a single "user" that is a piece of software, or
- You could reasonably expect your data to take up gigabytes of storage

** Flavors and Styles
"Databases" is a pretty large topic, and many engineers make long, successful
careers out of specializing in database development or administration, or their
skill in implementing particular kinds of databases. There are a lot of kinds of
databases we wont be spending very much time with, but it's worth knowing
something about the field -- what's available.

First, let's establish what a database /is/. I think of a database as having, at
minimum, two properties:

1. A database stores discrete pieces of data /on disk/, not (or not /just/) in
   memory.
2. A database offers a mechanism for /querying/ its contents.

Postgres, which many of you will be using, certainly satisfies both points: data
is written do disk, where it's safe; you can retrieve a piece of data from the
database pretty easily. LokiJS bills itself as an /in-memory database/ -- which is
to say, no kind of database at all. Loki is a data /store/, which is a perfectly
valid and excellent thing to be. But persistence isn't baked in to Loki; it can
make no guarantees about the safety of your data. Therefore: not a database.

Beyond those two properties, I find it useful to think of modern databases
according to how they organize their data -- what kind of /schema/ do they
use. We wind up with a couple rough categories:

*** Relational databases
A relational database stores data in units of rows and columns -- each row is an
entity, each column is a thing we can know about that entity. One particular
grouping of rows and columns is a table. Two tables can be connected (that is,
/related/) by mutual columns, allowing the construction of larger and more
sophisticated views of the data.

Relational databases often have the property of being /transactional/. A
transaction is a way of grouping and thinking about the set of changes you're
going to make to a database.

We'll be using and talking about relational databases almost exclusively for the
foreseeable future of the SDS.

Common Relational Databases:
- PostgreSQL
- MySQL
- Microsoft SQL Server

*** Column Stores
While a relational database stores your data in tables, a column store
associates a key with a column. That is: where a relational database stores
pieces of data grouped together by some kind of semantic meaning, a column store
tries to group all the data together that pertains to a single entity. While you
as a user might have information stored in a relational database in a ~customers~
table and an ~addresses~ table and a ~purchases~ table, in a column store, all the
data for you would be stored in a single you-column.

Common Column Stores:
- Amazon RedShift
- Cassandra
- Druid
- HBase

*** Key-value Stores
A key-value store is, effectively, a schema-less place to put data. Sometimes
called "NoSQL" databases, these systems hang on to some kind of blob of
information and hand it back to you when you ask.

This is... not as often a good idea as the makers would have you believe.

Notable key-value stores:
- Redis
- MongoDB
- Couchbase

*** Remember, kids:
If it doesn't persist to disk, /it's not a database/. Redis? Not a database.

** Let's Refactor some Information
Let's imagine we're working with the purchase record of a small business. It's
been growing lately, and we're going to try and help move the purchase record
from the one-computer-at-a-time point-of-sale format it's in to something
appropriate for a database. Right now, the purchase record looks like this:

| Name           | Address                                        | Phone Number   | Item               | Price | Kind     |
|----------------+------------------------------------------------+----------------+--------------------+-------+----------|
| Rowan Scott    | 3172 NE Hampstead Rd, New York, New York 12345 | 123-456-7899   | Carpet, very large |  2000 | Shipped  |
| Rowan Scott    | 3172 NE Hampstead Rd, New York, New York 12345 | 123 456-7899   | Tea kettle, brass  |    58 | Shipped  |
| Devon Grantham | 58 Prescott Place, Wichita, Kansas 54321       | (821) 954-2186 | Monkey, Statue of  |   100 | In-store |
| Van Rijn       | 805 SE Belmont, Portland, OR 97214             | 503.554.5108   | Carpet, medium     |  1000 |          |
| Rowan Scott    | 3172 NE Hampstead Rd, New York, New York 12345 | 1234567899     | table              |   250 | Shipped  |
| Devon Grantham | 58 Prescott Place, Wichita, Kansas 54321       | (821) 954-2186 | Monkey, Statue of  |   100 | In-store |

*** Uniqueness
So there's a lot going on there -- we've got a lot of work to do. The first and
second rows -- were they the same order? There are no order numbers. Nothing is
enforcing a format in the phone number field. Also, the full address is printed
every time. Did Devon Grantham buy the same monkey statue twice? Why are there
no item numbers?

We sit down and do a long interview with the owner, and eventually, the record
looks more like this:

| Name           | Address                                        | Phone Number   | Item               | Item no. | Price | Order No. | Kind     |
|----------------+------------------------------------------------+----------------+--------------------+----------+-------+-----------+----------|
| Rowan Scott    | 3172 NE Hampstead Rd, New York, New York 12345 | 123-456-7899   | Carpet, very large |     7899 |  2000 |      1003 | Shipped  |
| Rowan Scott    | 3172 NE Hampstead Rd, New York, New York 12345 | 123 456-7899   | Tea kettle, brass  |      214 |    58 |      1003 | Shipped  |
| Devon Grantham | 58 Prescott Place, Wichita, Kansas 54321       | (821) 954-2186 | Monkey, Statue of  |      314 |   100 |      1004 | In-store |
| Van Rijn       | 805 SE Belmont, Portland, OR 97214             | 503.554.5108   | Carpet, medium     |     1689 |  1000 |      1005 |          |
| Rowan Scott    | 3172 NE Hampstead Rd, New York, New York 12345 | 1234567899     | table              |       21 |   250 |      1006 | Shipped  |
| Devon Grantham | 58 Prescott Place, Wichita, Kansas 54321       | (821) 954-2186 | Monkey, Statue of  |      315 |   100 |      1004 | In-store |

So that's somewhat reassuring. Devon bought a matched set of monkey statues, and
Rowan Scott has actually only made two orders. We still don't know how Van Rijn
got their order at all, so that's neat, but we're making some progress. The most
important thing we've done is to make every row /unique/. When we started, several
of the rows were distinguishable from one another only from typos. Uniqueness of
row is a very good database property indeed.

But oye, is there more to do.

*** Breaking out a Customer Record
Let's look at our first three columns. Each row in those three columns describes
a person -- a customer. A lot of information is being repeated. Consider: those
three columns make perfect sense on their own:

| Name           | Address                                        | Phone Number   |
|----------------+------------------------------------------------+----------------|
| Rowan Scott    | 3172 NE Hampstead Rd, New York, New York 12345 | 123-456-7899   |
| Rowan Scott    | 3172 NE Hampstead Rd, New York, New York 12345 | 123 456-7899   |
| Devon Grantham | 58 Prescott Place, Wichita, Kansas 54321       | (821) 954-2186 |
| Van Rijn       | 805 SE Belmont, Portland, OR 97214             | 503.554.5108   |
| Rowan Scott    | 3172 NE Hampstead Rd, New York, New York 12345 | 1234567899     |
| Devon Grantham | 58 Prescott Place, Wichita, Kansas 54321       | (821) 954-2186 |

In fact, they actually make /more/ sense on their own. Now we can get rid of
duplicate rows:

| Name           | Address                                        |   Phone Number |
|----------------+------------------------------------------------+----------------|
| Rowan Scott    | 3172 NE Hampstead Rd, New York, New York 12345 |   123-456-7899 |
| Devon Grantham | 58 Prescott Place, Wichita, Kansas 54321       | (821) 954-2186 |
| Van Rijn       | 805 SE Belmont, Portland, OR 97214             |   503.554.5108 |

Better and better. Now, let's turn back to our original purchase record. How do
we connect what we've just made back to the original data? Hang on: we're about
to get Relational.

First, let's give each customer a unique ID:

| ID | Name           | Address                                        |   Phone Number |
|----+----------------+------------------------------------------------+----------------|
|  1 | Rowan Scott    | 3172 NE Hampstead Rd, New York, New York 12345 |   123-456-7899 |
|  2 | Devon Grantham | 58 Prescott Place, Wichita, Kansas 54321       | (821) 954-2186 |
|  3 | Van Rijn       | 805 SE Belmont, Portland, OR 97214             |   503.554.5108 |

Now, we replace the first three columns in our original purchase record with a
single column; so as not to get confused, let's call that column "Customer ID":

| Customer ID | Item               | Item no. | Price | Order No. | Kind     |
|-------------+--------------------+----------+-------+-----------+----------|
|           1 | Carpet, very large |     7899 |  2000 |      1003 | Shipped  |
|           1 | Tea kettle, brass  |      214 |    58 |      1003 | Shipped  |
|           2 | Monkey, Statue of  |      314 |   100 |      1004 | In-store |
|           3 | Carpet, medium     |     1689 |  1000 |      1005 |          |
|           1 | table              |       21 |   250 |      1006 | Shipped  |
|           2 | Monkey, Statue of  |      315 |   100 |      1004 | In-store |

What we've just done is to create an entity, which we'll call Customers. Each
row in the Customers entity is unique, and has a column which is known to be
totally unique. (We didn't use /name/ for this because two people might have the
same name, eh?) This known-unique column is our /primary key/. We always know
that, when we say "Customer ID 2", we always mean "Devon Grantham".

We then replaced all teh duplicate information in or original purchase record
with our Customer IDs. We'll now name our original purchase record entity
Purchases. In the context of Purchases, "Customer ID" is a /foreign key/. It's
known to be a key, but it belongs to an entity other than the current one.

Back at our customer record, we'll make one more change: let's make a separate
column for everything that can sensibly be in its own column.

| ID | Name           | Street Address       | City     | State    | Zipcode |   Phone Number |
|----+----------------+----------------------+----------+----------+---------+----------------|
|  1 | Rowan Scott    | 3172 NE Hampstead Rd | New York | New York |   12345 |   123-456-7899 |
|  2 | Devon Grantham | 58 Prescott Place    | Wichita  | Kansas   |   54321 | (821) 954-2186 |
|  3 | Van Rijn       | 805 SE Belmont       | Portland | OR       |   97214 |   503.554.5108 |

There we go. That's pretty nice. There are still little pieces of cruft --
inconsistent phone number formats, for instance. But in general, we've made
something we can work with. We'll do exactly this, again, with Items:

| Item               |   ID | Price |
|--------------------+------+-------|
| Carpet, very large | 7899 |  2000 |
| Tea kettle, brass  |  214 |    58 |
| Monkey, Statue of  |  314 |   100 |
| Carpet, medium     | 1689 |  1000 |
| table              |   21 |   250 |
| Monkey, Statue of  |  315 |   100 |

We're left with a pretty good start at a Purchases record:

| Customer ID | Item ID | Order No. | Kind     |
|-------------+---------+-----------+----------|
|           1 |    7899 |      1003 | Shipped  |
|           1 |     214 |      1003 | Shipped  |
|           2 |     314 |      1004 | In-store |
|           3 |    1689 |      1005 |          |
|           1 |      21 |      1006 | Shipped  |
|           2 |     315 |      1004 | In-store |

*** Refining Purchases
We've made great progress on our refactor of that purchase record! We've made
two new entities, Items and Customers, given them primary keys, and assigned
those as foreign keys to the new Purchases entity. Next step: Purchases doesn't
have a primary key, does it?

But: adding a primary key isn't immediately, semantically obvious. We have an
order number, sure, but how do we map a given Purchase, and Order Number, and
the items in the order together?

We're dealing with a multiplicity of relationships problem. Purchases has, for
example, a one-to-one relationship with Customers -- a Purchase can have only
one customer, and that customer will have a single row in Customers. Purchases
and Orders have a one-to-one relationship -- you pay once for one order. But
Orders and Items have a many-to-many relationship: one item can be in many
orders and one order can contain many items.

What we need is an intermediary -- something that Purchases can have a
one-to-one or one-to-many relationship with, and that can have a many-to-one
relationship with Items. Let's make an Orders entity, renaming Order Number to
Order ID:

| Order ID | Item ID |
|----------+---------|
|     1003 |    7899 |
|     1003 |     214 |
|     1004 |     314 |
|     1005 |    1689 |
|     1006 |      21 |
|     1004 |     315 |

Notice that there is no primary key, and yet every row is unique. Each /pair/ of
data is effectively a key in this Entity.

Now, Purchases can be reduced and have an ID:

| Customer ID | ID | Order ID | Kind     |
|-------------+----+----------+----------|
|           1 |  1 |     1003 | Shipped  |
|           2 |  2 |     1004 | In-store |
|           3 |  3 |     1005 |          |
|           1 |  4 |     1006 | Shipped  |

Beautiful.

*** So What's Missing?
There are some things this lacks. The first, most obvious thing to me is /time/ --
nothing has a timestamp. In almost every table in almost every relational
database, a row should have a timestamp, either specifying when the row was
created or when it was updated. Other than that:
- The Orders table should probably specify what quantity of each item is being
  bought at a time. It's date column will indicate when an order was placed.
- The Purchases entity should probably have a calculated column called "total",
  representing the sum of item price times quantity for all items in a an
  order. Also, "kind" should be renamed to something clearer. The date column
  here will indicate when a purchase went through -- when payment was received
  and the transaction was considered "finished."
- Items should have number in stock

Now, most of that information was missing from the original data, but let's play
the role of the eternal optimist -- let's imagine that we take our work back to
the person we're working for and they're able to help us build a record that
makes sense.

*** So what's the result?
Here's what we've made:

**** Purchases
| ID | Customer ID | Order ID | Purchase Date | Total | Delivery Method |
|----+-------------+----------+---------------+-------+-----------------|
|  1 |           1 |     1003 |    2015-01-01 |  2058 | Shipped         |
|  2 |           2 |     1004 |    2015-01-02 |   200 | In-store        |
|  3 |           3 |     1005 |    2015-02-02 |  1000 |                 |
|  4 |           1 |     1006 |    2015-01-30 |   250 | Shipped         |

**** Orders
| Order ID | Item ID | Item Quantity | Order Date |
|----------+---------+---------------+------------|
|     1003 |    7899 |             1 | 2014-12-31 |
|     1003 |     214 |             1 | 2014-12-31 |
|     1004 |     314 |             1 | 2015-01-01 |
|     1005 |    1689 |             1 | 2015-01-31 |
|     1006 |      21 |             1 | 2015-01-30 |
|     1004 |     315 |             1 | 2014-12-31 |

**** Items
| Item               |   ID | In Stock | Price | Updated On |
|--------------------+------+----------+-------+------------|
| Carpet, very large | 7899 |        0 |  2000 | 2016-03-22 |
| Tea kettle, brass  |  214 |        0 |    58 | 2016-03-22 |
| Monkey, Statue of  |  314 |        0 |   100 | 2016-03-22 |
| Carpet, medium     | 1689 |        0 |  1000 | 2016-03-22 |
| table              |   21 |        0 |   250 | 2016-03-22 |
| Monkey, Statue of  |  315 |        0 |   100 | 2016-03-22 |

**** Customers
| ID | Name           | Street Address       | City     | State    | Zipcode |   Phone Number | Updated On |
|----+----------------+----------------------+----------+----------+---------+----------------+------------|
|  1 | Rowan Scott    | 3172 NE Hampstead Rd | New York | New York |   12345 |   123-456-7899 | 2016-03-22 |
|  2 | Devon Grantham | 58 Prescott Place    | Wichita  | Kansas   |   54321 | (821) 954-2186 | 2016-03-22 |
|  3 | Van Rijn       | 805 SE Belmont       | Portland | OR       |   97214 |   503.554.5108 | 2016-03-22 |

*** So, why is this good?
I'd like to spend a moment on this -- it's worth thinking about. After all: the
set of entities we've made above has fragmented one record in to /four/. What,
specifically, do we get out of this?

1. You have probably guessed this, but what we've made is going to be *much*
   easier to build a functioning database with than what we started with. We can
   use what we've developed here to produce a database /schema/.
2. What we've produced here is dramatically easier to keep up to date and
   accurate. Consider: we only have *one* place to update if Van Rijn's address
   changes. Now: that also means that if we update data, historical data is lost
   -- but this model also allows us to fix that, if we'd like. We know how many
   of a given item we have, and its current price (again, another piece of data
   we'll want to work with in the future.)
3. We can now answer more specific questions more easily. "How many customers do
   we have in Portland" would have been a tedious chore in the old system; it's
   comparatively easy in the new one.

Our data at this point has a special property: it's in First Normal Form
(abbreviated 1NF). Every entity contains no duplicate rows and has a clear way
to identify a row as unique.[fn:4] This matters partly for questions of database
usability -- imagine how much harder it would be to write code to update a
customer's address if you had multiple addresses, or if each address came as a
single string unit along with a customer's full name.

The other part of 1NF's value is its role in being able to assert the
correctness of the data in a database. The theoretical underpinning of
relational databases is a field called [[https://en.wikipedia.org/wiki/Relational_algebra][Relational Algebra]] by making sure the
schema of a database conforms to certain restrictions, like 1NF, let's us use
tools like SQL to query our data with confidence that the answer will be
correct.

Correct normalization is also an important part of the ACID standard.

*** ACID
ACID is a set of standards for data in transactional/relational databases:

- *A*: Atomicity. A transaction is all-or-nothing; if any part of a transaction
  fails, the entire transaction fails, and no change is affected in the data. If
  the transaction succeeds, we know it *all* succeeded.
- C: Consistency. A transaction will transition a database from one valid state
  to a new valid state, where "valid" is defined by a certain set of known
  rules. This is a bounded consistency. The database cannot, for instance, stop
  you from setting a customer's address to "12345 Butts Butts Butts", but it /can/
  have a constraint against the address being empty.
- *I*: Isolation. This property manages the effect of concurrent transactions on
  the same data, and makes guarantees about the outcome of those
  transactions. Most typically, the outcome of two concurrent transactions
  should be identical to the same two transactions being applied in serial,
  though this can sometimes be configured in the database.
- D: Durability. Committed transactions are never lost. If the database crashes,
  looses power, is cut off from the network -- every committed transaction is
  safe.

** Defining a database schema
Let's consider our ~items~ table:

| Item               |   ID | In Stock | Price | Updated On |
|--------------------+------+----------+-------+------------|
| Carpet, very large | 7899 |        0 |  2000 | 2016-03-22 |
| Tea kettle, brass  |  214 |        0 |    58 | 2016-03-22 |
| Monkey, Statue of  |  314 |        0 |   100 | 2016-03-22 |
| Carpet, medium     | 1689 |        0 |  1000 | 2016-03-22 |
| table              |   21 |        0 |   250 | 2016-03-22 |
| Monkey, Statue of  |  315 |        0 |   100 | 2016-03-22 |

We know the name of this entity: ~items~. Our next task is to describe the columns
in each entity. This means knowing something of the /type/ of each column, and
also the constraints we want the database to impose. We'll start by transposing
the table, and removing everything but the column names:

| Item       |
| ID         |
| In Stock   |
| Price      |
| Updated On |

While we're at it, let's tidy up these names to something more idiomatic for a
database:

| Column Name     |
|-----------------|
| item_name       |
| id              |
| number_in_stock |
| price           |
| updated_on      |

Great. Lets think about types.

*** Types
We already know something about the types of each thing, so let's notate that:

| Column Name     | Type    |
|-----------------+---------|
| item_name       | String  |
| id              | Integer |
| number_in_stock | Integer |
| price           | Float   |
| updated_on      | Date    |

Every database has its own types; I'll add the equivalent Postgres types here:

| Column Name     | Type    | PG Type                 |
|-----------------+---------+-------------------------|
| item_name       | String  | ~varchar(100)~            |
| id              | Integer | ~integer~                 |
| number_in_stock | Integer | ~integer~                 |
| price           | Float   | ~numeric(10, 2)~          |
| updated_on      | Date    | ~timestamp with timezone~ |

~varchar~, a shortening of "character varying", is what it sounds like -- a string
field of bounded length. ~integer~ is a 32-bit signed integer, and is Postgres'
standard for most whole numbers. ~numeric~ is a user-specified precision decimal
number; here we specify it has ten total digits with two digits of
precision. Lastly, ~timestamp~ -- which comprises both date and time; I've chosen
to specify timezone, which is optional, but encouraged.

In general, pick the smallest unit that will satisfy your needs. For instance:
we choose a bounded ~varchar(100)~ for our ~items~, instead of the unbounded (and
thus more expensive to store) ~text~. It's important to understand what your needs
/are/, so you can avoid making an unnecessary  crusade of optimization you don't
need. For instance ~integer~ takes 4 bytes of storage, while ~smallint~
only takes two. So, does it matter that we picked ~integer~ for our ~items~ schema?
Remember, our motivating hypothetical is a store that's /just/ grown big enough to
need a database. It's unlikely such a store would have /so many/ items in stock
that use of an ~integer~ would make a different. On the other hand, if you were to
ever design a database schema for a business doing lots and /lots/ of retail on
the internet, you'd want to think very carefully about the storage needs of
whatever table stores purchase transactions -- that table might get huge, fast.

Can you change schemas later? Why yes! How difficult this is to do is a function
of a lot of factors that are hard to predict. How difficult is it to take "down
time" -- shut down your service while you modify the database? How big is your
data set? Are you well provisioned -- that is, you have plenty of extra
resources around -- or under-provisioned? But: schemas are not set in stone. You
don't have to get them right the first time /or else/.

*** Properties and Constraints
Relational databases give us a rich language in which to describe expectations
about our data. Some of this relates to what we've been talking about -- which
columns are keys? Other times, we describe constraints around our data. Can a
given datum be missing? What default values can be used?

To give us very slightly more to talk about, I'm going to first make two changes
to our nascent schema. First: I'm going to change ~id~ to ~inventory_number~, and
add ~id~ back in as an integer column the database will use to guarantee
uniqueness. Second, I'm going to add an ~item_description~ field. Like so:

| Column Name      | Type    | PG Type                  |
|------------------+---------+--------------------------|
| item_name        | String  | ~varchar(100)~             |
| inventory_number | Integer | ~integer~                  |
| id               | Integer | ~integer~                  |
| number_in_stock  | Integer | ~integer~                  |
| price            | Float   | ~numeric(10, 2)~           |
| updated_on       | Date    | ~timestamp with time zone~ |
| item_description | String  | ~text~                     |

Given this, let's start with a prose description of this data:

#+BEGIN_QUOTE
Every item is required to have a name and inventory number -- there's no
sensible default value for either. The inventory number should be unique, but
the item name doesn't have to be. The id of an item should be the next higher id
after the last id added. If no number of units in stock is provided, default to
zero; do not let this be negative. If no price is specified, default to zero
dollars and zero cents; do not allow this to be negative. Item description can
be omitted entirely. Updated on should always be the timestamp of the last time
this row was modified. Because we're sure id will always be unique, it will be
our primary key.
#+END_QUOTE

Now, in Postgres terms:

| Column Name      | Type    | PG Type                  | Properties                             |
|------------------+---------+--------------------------+----------------------------------------|
| item_name        | String  | ~varchar(100)~             | ~NOT NULL~                               |
| inventory_number | Integer | ~integer~                  | ~NOT NULL UNIQUE~                        |
| id               | Integer | ~integer~                  | ~PRIMARY KEY SERIAL~                     |
| number_in_stock  | Integer | ~integer~                  | ~DEFAULT 0 CHECK (number_in_stock >= 0)~ |
| price            | Float   | ~numeric(10, 2)~           | ~DEFAULT 0.00 CHECK (price >= 0)~        |
| updated_on       | Date    | ~timestamp with time zone~ | ~DEFAULT CURRENT_TIMESTAMP~              |
| item_description | String  | ~text~                     | NULL                                   |

Et voila. It's a schema for a single database table! This could be converted in
to a ~CREATE TABLE~ statement with very little work:

#+BEGIN_SRC sql :exports code :eval never
  CREATE TABLE items (
         item_name varchar(100) NOT NULL,
         inventory_number integer NOT NULL UNIQUE,
         id integer PRIMARY KEY SERIAL,
         number_in_stock integer DEFAULT 0 CHECK (number_in_stock > 0),
         price numeric(10,2) DEFAULT 0.00 CHECK (price > 0),
         updated_on timestamp with time zone DEFAULT CURRENT_TIMESTAMP,
         item_description text
  );
#+END_SRC

*** In Conclusion
At this point, we're pretty much ready to make a database! Which we will do!
Next week.

I leave you with the completed schemas, for your reference:

**** customers

|----------------+--------------------------+-----------------------------------------|
| Column Name    | PG Type                  | Properties                              |
|----------------+--------------------------+-----------------------------------------|
| id             | ~integer~                  | ~PRIMARY KEY SERIAL~                      |
| name           | ~varchar(100)~             | ~NOT NULL~                                |
| street_address | ~varchar(100)~             | ~NULL CHECK (zipcode IS NOT NULL)~        |
| city           | ~varchar(100)~             | ~NULL CHECK (street_address IS NOT NULL)~ |
| state          | ~varchar(2)~               | ~NULL CHECK (city IS NOT NULL)~           |
| zipcode        | ~numeric(5)~               | ~NULL CHECK (state IS NOT NULL)~          |
| phone_number   | ~numeric(10)~              | ~NOT NULL~                                |
| updated_on     | ~timestamp with time zone~ | ~DEFAULT CURRENT_TIMESTAMP~               |
|----------------+--------------------------+-----------------------------------------|

This set of checks dictates that if one of ~street_address~, ~city~, ~state~, ~zipcode~
are set, the other three must be set.

**** items
|------------------+---------+--------------------------+---------------------------------------|
| Column Name      | Type    | PG Type                  | Properties                            |
|------------------+---------+--------------------------+---------------------------------------|
| item_name        | String  | ~varchar(100)~             | ~NOT NULL~                              |
| inventory_number | Integer | ~integer~                  | ~NOT NULL UNIQUE~                       |
| id               | Integer | ~integer~                  | ~PRIMARY KEY SERIAL~                    |
| number_in_stock  | Integer | ~integer~                  | ~DEFAULT 0 CHECK (number_in_stock > 0)~ |
| price            | Float   | ~numeric(10, 2)~           | ~DEFAULT 0.00 CHECK (price > 0)~        |
| updated_on       | Date    | ~timestamp with time zone~ | ~DEFAULT CURRENT_TIMESTAMP~             |
| item_description | String  | ~text~                     | ~NULL~                                  |
|------------------+---------+--------------------------+---------------------------------------|

**** purchases

|-----------------+-----------------------------+---------------------------|
| Column Name     | PG Type                     | Properties                |
|-----------------+-----------------------------+---------------------------|
| id              | ~integer~                     | ~PRIMARY KEY SERIAL~        |
| customer_id     | ~integer~                     | ~REFERENCES customers (id)~ |
| order_id        | ~integer~                     | ~REFERENCES orders (id)~    |
| purchase_date   | ~timestamp with time zone~    | ~NOT NULL~                  |
| updated_on      | ~timestamp with time zone~    | ~DEFAULT CURRENT_TIMESTAMP~ |
| total           | ~numeric(10,2)~               | ~NOT NULL~                  |
| delivery_method | ~enum('in-store', 'shipped')~ | ~NULL~                      |
|-----------------+-----------------------------+---------------------------|

This schema uses the SQL ~enumeration~ type, which restricts the the value of the
column to a specified set of values.

**** orders

|---------------+--------------------------+---------------------------|
| Column Name   | PG Type                  | Properties                |
|---------------+--------------------------+---------------------------|
| order_id      | ~integer~                  | ~REFERENCES orders (id)~    |
| item_id       | ~integer~                  | ~REFERENCES items (id)~     |
| item_quantity | ~integer~                  | ~NOT NULL~                  |
| ordered_on    | ~timestamp with time zone~ | ~DEFAULT CURRENT_TIMESTAMP~ |
|---------------+--------------------------+---------------------------|

*** Exercise: make your own schema

**** Classes
|----------------+---------------+------------+--------------------+------------+-------------------+----------------+------------+------------------+--------------------+------------|
| Course Name    | Course Number | Room       | Computers in Room? | Projector? | Maximum Occupancy | Student Name   | Student ID | Status           | Professor          | Department |
|----------------+---------------+------------+--------------------+------------+-------------------+----------------+------------+------------------+--------------------+------------|
| Humanities 110 |           110 | ETC 225    | Yes                | Yes        |                30 | Ross Donaldson | A123456    | Quadruple-Senior | Steven Wasserstrom | Religion   |
| Humanities 110 |           110 | Elliot 138 | No                 | Yes        |                15 | Harmon Kardon  | B654321    | Freshman         | Nigel Nicholson    | Classics   |
|----------------+---------------+------------+--------------------+------------+-------------------+----------------+------------+------------------+--------------------+------------|

**** Game Events
|--------+--------------------+------+------------+-----------+-------+-------+------+-------------------------------------+----------+--------------------+---------------|
| Player | Character          | Tier | Hit Points | Class     | Level |    XP | Gold | Inventory                           | Action   | Action Target      | Action Effect |
|--------+--------------------+------+------------+-----------+-------+-------+------+-------------------------------------+----------+--------------------+---------------|
| Ross   | Bork the Barbarian | Free |        100 | Barbarian |     5 | 12391 |    0 | Club, Armor, Roast Chicken, Boots   | Attack   | Orc                | 12 damage     |
| n/a    | Orc                | n/a  |         30 | n/a       |     3 |   500 |   10 | Sword, Orc Hat                      | Attacked | Bork the Barbarian | 12 damage     |
| n/a    | Orc                | n/a  |         18 | n/a       |     3 |   500 |   10 | Sword, Orc Hat                      | Attack   | Bork the Barbarian | 8 damage      |
| Bey    | Morrigan           | Paid |       5000 | Wizard    |    35 | 28549 | 3000 | Mega Wand, Platinum Single          | Buy      | Rad Hat            | 20 gold       |
| Ross   | Bork the Barbarian | Free |         92 | Barbarian |     5 | 12391 |    0 | Club, Armor, Roast Chicken, Boots   | Attacked | Orc                | 8 damage      |
| Bey    | Morrigan           | Paid |       5000 | Wizard    |    35 | 28549 | 2980 | Mega Wand, Platinum Single, Rad Hat | Receive  | Rad Hat            | -20 gold      |
|--------+--------------------+------+------------+-----------+-------+-------+------+-------------------------------------+----------+--------------------+---------------|

**** Library
|-------------------------+----------------------------------------------------------+----------+------------+-----------+----------------+-------+---------+------------------+------------+------------+-----------------------------------------------|
| Title                   | Author                                                   | Type     | Issue Date | In Print? | Publisher      | Total | Present | On-Loan To       |   Due Date | For Course | Location                                      |
|-------------------------+----------------------------------------------------------+----------+------------+-----------+----------------+-------+---------+------------------+------------+------------+-----------------------------------------------|
| The Wind in the Willows | Kenneth Grahame                                          | Book     |       1908 | Yes       | Methuen        |     5 |       3 | Ross Donaldson   | 2016-04-10 | n/a        | Reed Library Pollock Room (PR4726 .W5 1940b ) |
| The Wind in the Willows | Kenneth Grahame                                          | Book     |       1908 | Yes       | Methuen        |     5 |       3 | Student McAlumni | 2016-05-10 | Lit 235    | Reed Library Pollock Room (PR4726 .W5 1940b ) |
| Romeo and Juliette      | Sergey Prokofiev, Esa-Pekka Salonen, Berlin Philharmonic | Audio CD |            |           | Sony Classical |     1 |       1 |                  |            | Music 348  | Online Access                                 |
|-------------------------+----------------------------------------------------------+----------+------------+-----------+----------------+-------+---------+------------------+------------+------------+-----------------------------------------------|

* <2017-03-21 Tue> -- Database, Part Two: the Sequel
:PROPERTIES:
:EXPORT_FILE_NAME: lesson_07_databases_part_two.md
:END:

#+BEGIN_SRC sh :exports none
dropdb db_lesson_sql
dropdb db_lesson_orm
#+END_SRC

Last week we worked through the process of defining a database schema. This week
we're going to work through two different approaches to creating and interacting
with a database. We'll look at a raw Structured Query Language (SQL) approach;
we'll work through the same example using an Object-Relational Mapper (ORM).

** Getting Setup

*** Installing Postgres
First things first: installing a database. A database is its own kind of
program; it needs to be run and managed separately from the code you write. Both
the SQL and ORM approaches require a database, run in the same way. For our work
here, we'll be using Postgres.

You have two choices: [[http://postgresapp.com/][Postgres.app]], or homebrew. Both do pretty much the same
thing: install a Postgres database and the ~psql~ CLI on your computer. Heroku's
Postgres.app makes running your database slightly less arcane; the flip side is
that installing and running your database via homebrew is more "standard" -- so
these notes will assume that's what you're up to.

My friends, let us begin:

#+BEGIN_SRC sh :eval never :exports code
brew install postgresql
#+END_SRC

If all goes well, your output should end with something like:
#+BEGIN_EXAMPLE
To have launchd start postgresql at login:
  ln -sfv /usr/local/opt/postgresql/*.plist ~/Library/LaunchAgents
Then to load postgresql now:
  launchctl load ~/Library/LaunchAgents/homebrew.mxcl.postgresql.plist
Or, if you don't want/need launchctl, you can just run:
  postgres -D /usr/local/var/postgres
==> Summary
/usr/local/Cellar/postgresql/9.5.1: 3,118 files, 35M
#+END_EXAMPLE

I find this output a little arcane, myself, so let's do a quick breakdown of the
three things in there:

1. You can tell your Mac to turn Postgres on every time the computer turns
   on. To do this, run the first command.
2. If you've decided to wire things up with command 1, Postgres will now start
   when your computer boots. However, it will not be running /right now/. To make
   it run right now, /if/ you went with command 1, run command 2.
3. Or, you can choose to run Postgres manually, so it's only on when you need it
   to be. To run Postgres manually, run the third command.

If performance isn't a concern for your laptop or if you're going to be using
Postgres /all the flipping time/, maybe do commands 1 and 2. If performance /is/ a
concern for your Mac, or if you just don't like unnecessary software cluttering
things up, skip 1 and 2 and just use command 3 whenever you need it.[fn:6]

*** Making Databases
At this point you've got postgres installed! Rad. So that's a /database/, but it
turns out, there are no /databases/ in it yet. Vis:

#+BEGIN_EXAMPLE
$ psql
psql: FATAL:  database "rossdonaldson" does not exist
#+END_EXAMPLE

Postgres is a "database" -- that is, that's the type of program Postgres is. But
it can also contain many "databases" -- that is, groupings of tables, users, and
permissions. What's happening at our command line is that by default, when you
call ~psql~, Postgres will try to connect you to a database named after your
current user.

We can fix this with ~createdb~:
#+BEGIN_EXAMPLE
$ createdb rossdonaldson
$ psql
psql (9.5.1)
Type "help" for help.

rossdonaldson=#
#+END_EXAMPLE

Sweet. Now we need two more databases: one for our SQL lesson, and one for the
ORM lesson. Exit ~psql~ (if you started it) and do two more ~createdb~ invocations:

#+BEGIN_SRC sh :exports both
createdb db_lesson_sql
createdb db_lesson_orm
#+END_SRC

Raaaad.

*** Talking through our demonstration data
Last week we did a set of information refactoring work and eventually produced
schemas we could make databases out of. We'll be coming back to those, but for
now, we'll take a vastly simpler approach. We're going to model people, foods,
and people's preferences for different foods, like so:

**** people
|-------------+--------------------------+---------------------------|
| Column Name | Type                     | Properties                |
|-------------+--------------------------+---------------------------|
| id          | INTEGER                  | PRIMARY KEY SERIAL        |
| first_name  | VARCHAR(20)              | NOT NULL                  |
| last_name   | VARCHAR(30)              | NOT NULL                  |
| created_on  | TIMESTAMP WITH TIME ZONE | DEFAULT CURRENT_TIMESTAMP |
|-------------+--------------------------+---------------------------|


**** foods
|-------------+--------------------------+---------------------------|
| Column Name | Type                     | Properties                |
|-------------+--------------------------+---------------------------|
| id          | INTEGER                  | PRIMARY KEY SERIAL        |
| name        | VARCHAR(50)              | NOT NULL                  |
| kind        | VARCHAR(10)              | NULL                      |
| description | TEXT                     | NULL                      |
| updated_on  | TIMESTAMP WITH TIME ZONE | DEFAULT CURRENT_TIMESTAMP |
|-------------+--------------------------+---------------------------|

**** preferences
|-------------+-----------------------------+--------------------------------|
| Column Name | Type                        | Properties                     |
|-------------+-----------------------------+--------------------------------|
| id          | INTEGER                     | PRIMARY KEY SERIAL             |
| person_id   | INTEGER                     | NOT NULL REFERENCES people(id) |
| food_id     | INTEGER                     | NOT NULL REFERENCES foods(id)  |
| attitude    | ENUM('love', 'hate', 'meh') | NOT NULL                       |
|-------------+-----------------------------+--------------------------------|


*** A couple quick notes about ~psql~
~psql~ is the Postgres command-line tool. Where calling ~python~ from the command
line gets you a REPL (read-eval-print loop), ~psql~ gets you a full-blown
application you can use to administer and interact with Postgres on your
computer. You may be thinking, "great, a full-blown application what does that
even mean?" Good question!

What I mean is that in ~psql~, you can type literal SQL and have it executed, /or/
you can use a variety of ~psql~ specific commands. For instance, we can list our
databases like so:
#+BEGIN_EXAMPLE
psql (9.5.1)
Type "help" for help.

rossdonaldson=# \l
                                           List of databases
     Name      |     Owner     | Encoding |   Collate   |    Ctype    |        Access privileges
---------------+---------------+----------+-------------+-------------+---------------------------------
 db_lesson_orm | rossdonaldson | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 db_lesson_sql | rossdonaldson | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 postgres      | rossdonaldson | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 rossdonaldson | rossdonaldson | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 template0     | rossdonaldson | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/rossdonaldson               +
               |               |          |             |             | rossdonaldson=CTc/rossdonaldson
 template1     | rossdonaldson | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/rossdonaldson               +
               |               |          |             |             | rossdonaldson=CTc/rossdonaldson
(6 rows)

rossdonaldson=#
#+END_EXAMPLE

~\l~ is no kind of SQL command -- it's a specific administration command to the
~psql~ client.

If we want to take action on a given database, we should first connect to that
database using ~\c~:

#+BEGIN_EXAMPLE
rossdonaldson=# \c rossdonaldson
You are now connected to database "rossdonaldson" as user "rossdonaldson".
rossdonaldson=#
#+END_EXAMPLE

There's very little in here right now so I can't show you anything else. But!
Postgres will cheerfully tell you how to use it. For help, use ~\?~. Here's the
first five lines of it (the output is too long to duplicate here):

#+BEGIN_EXAMPLE
rossdonaldson=# \?
General
  \copyright             show PostgreSQL usage and distribution terms
  \g [FILE] or ;         execute query (and send results to file or |pipe)
  \gset [PREFIX]         execute query and store results in psql variables
  \q                     quit psql
  \watch [SEC]           execute query every SEC seconds
#+END_EXAMPLE

** SQL
Let's get SQLing! Everything we'll be doing from here will be executed by
writing it in to the ~psql~ client. First, a couple of notes:

*** "The" SQL
There is "a" SQL, defined by the American National Standards Institute
(ANSI). It specifies how a SQL database ought to behave. And: nobody I know of
follows the ANSI standard precisely. Instead, every database is in its own
"dialect" of SQL. These dialects are very close to one another in major details,
but have small differences that can throw you well and truly Off. For instance,
in Postgres, to get the current date and time, you'd use `CURRENT_DATE`, which
is a constant; in MySQL, you use `CURDATE()`, which is a function. Whee? Whee.

*** Syntax
SQL is case INsensitive -- SQL doesn't care one whit which words you
capitalize or not. SQL also doesn't care about white space, other than at
minimum one whitespace character between words. This means these two queries are
totally identical, as far as SQL is concerned:

#+BEGIN_SRC sql :eval never
  -- you could do like this
  select foo, bar from place where thing = 'condition';

  -- or technically even like this
  Select
   foo
   ,                                  bar
   From BAR WHERE
   thing = 'condition'

  ;
#+END_SRC

I follow a pretty standard convention in my own SQL: tables and their columns
are always lower case; SQL reserved words are always in block caps; break
statements up on new lines; final semi-colon on its own line. Something like
this:

#+BEGIN_SRC sql :eval never
  SELECT foo
         , bar
  FROM place
  WHERE thing = 'condition'
        AND other_thing = 'different_condition'
  ;
#+END_SRC

*A-two*: a SQL statement always ends in ~;~, and ~psql~ will let you copy/paste or hit
"enter" as many times as you like without executing your code /until you add a ;/.

*** Setup
:PROPERTIES:
:header-args: :exports code :engine postgresql :database db_lesson_sql :results verbatim
:END:
**** Creating Tables

We saw a ~CREATE TABLE~ statement last time. Here's the [[http://www.postgresql.org/docs/9.5/static/sql-createtable.html][API documentation]] for
Postgres' ~CREATE TABLE~ statement. There are a /lot/ of options, so the doc is a
little daunting. Let's look at the pretty simple SQL that will make our ~people~
table:

#+BEGIN_SRC sql
  CREATE TABLE people (
         id SERIAL PRIMARY KEY,
         first_name VARCHAR(20) NOT NULL,
         last_name VARCHAR(30) NOT NULL,
         created_on TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
  );
#+END_SRC

~SERIAL~ is effectively the type of ~id~, so Postgres lets us use it on its
own. Everything else here is pretty bog-standard (and a lot less daunting than
the vast panoply of options Postgres supports). Here's the next two statements:

***** food
#+BEGIN_SRC sql
  CREATE TABLE food (
         id SERIAL PRIMARY KEY,
         name VARCHAR(50) NOT NULL,
         kind VARCHAR(10) NULL,
         description TEXT NULL,
         updated_on TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
  );
#+END_SRC

#+RESULTS:
: CREATE TABLE

***** preferences
Note something here: in Postgres, ~ENUM~ types cannot be declared in place -- we
need a separate ~CREATE TYPE~ statement:
#+BEGIN_SRC sql
    CREATE TYPE attitudes AS ENUM ('love', 'hate', 'meh');
    CREATE TABLE preferences (
           id SERIAL PRIMARY KEY,
           person_id INTEGER NOT NULL REFERENCES people(id),
           food_id INTEGER NOT NULL REFERENCES food(id),
           attitude attitudes NOT NULL,
           created_on TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
           updated_on TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
    );
#+END_SRC

#+RESULTS:
: CREATE TABLE

**** Loading some test data
We've got three tables! We can add data to them using the SQL ~INSERT~ statement.

Here are some people:

#+BEGIN_SRC sql
  INSERT INTO people (first_name, last_name)
  VALUES ('Captain', 'Vegetable')
         , ('Samus', 'Aran')
         , ('Bork', 'the Barbarian')
  ;
#+END_SRC

#+RESULTS:
: INSERT 0 3

And some foods:
#+BEGIN_SRC sql
  INSERT INTO food (name, kind, description)
  VALUES ('carrot', 'vegetable', 'how much beta carotene can be in one food IT IS SO MUCH')
         , ('celery', 'vegetable', 'eating crunchy vegetables is good for me')
         , ('quinoa', NULL, 'are we actually sure what this is?')
         , ('roast beef', 'meat', NULL)
         , ('tuna sandwich', 'sandwich', 'made with apples and sourdough bread')
  ;
#+END_SRC

#+RESULTS:
: INSERT 0 5

And some preferences:

#+BEGIN_SRC sql
  INSERT INTO preferences (person_id, food_id, attitude)
  VALUES (1, 1, 'love')
         , (1, 2, 'love')
         , (1, 3, 'meh')
         , (1, 4, 'hate')
         , (2, 1, 'hate')
         , (2, 5, 'love')
         , (3, 4, 'love')
         , (3, 1, 'love')
  ;
#+END_SRC

#+RESULTS:
: INSERT 0 7

Some things to notice about all of this:
- ~VALUES~ clauses must all be of identical length, which means we have to pass
  ~NULL~ as the description of ~roast beef~.
- We have to specify both ~people~ and ~foods~ by ~id~ to insert them in to the
  ~preferences~ table, which can get cumbersome.
- While we pass ~ENUM~ values as strings, we'll get an error if we try to pass a
  string we didn't put in the ~ENUM~:

#+BEGIN_SRC sql :eval never :exports code
  INSERT INTO preferences (person_id, food_id, attitude)
  VALUES (1, 1, 'hoobastank');
#+END_SRC

#+BEGIN_EXAMPLE
ERROR:  invalid input value for enum attitudes: "hoobastank"
LINE 2: VALUES (1, 1, 'hoobastank');
#+END_EXAMPLE

*** Querying
:PROPERTIES:
:header-args: :exports code :engine postgresql :database db_lesson_sql :results table
:END:

**** ~SELECT~

Now that we have tables, there's a *lot* we can do. Recall that SQL stands for
Structured Query Language -- so let's write some queries!

A SQL query has this basic form:
#+BEGIN_SRC sql :eval never :exports code
  SELECT column_name_one, column_name_two
  FROM table_name
  (optionally) WHERE condition = value;
#+END_SRC

Each part of a SQL query is called a /clause/ -- for instance, the ~SELECT~ clause
versus the ~FROM~ clause. The ~SELECT~ clause specifies what we want to return out
of the entities specified in our ~FROM~ clause, optionally pared down by
statements in the ~WHERE~ clause.

So for instance, what are the names of all the vegetables in the ~foods~ table?
#+BEGIN_SRC sql
SELECT name
FROM food
WHERE kind = 'vegetable';
#+END_SRC

#+RESULTS:
| name   |
|--------|
| carrot |
| celery |

The ~WHERE~ clause supports an incredible number of operations, including boolean
comparison, greater-than/less-than, string comparison, and lots, lots more.

In our ~SELECT~ clause, we can use an asterisk to get /all/ of something from a place:

#+BEGIN_SRC sql
SELECT *
FROM people
#+END_SRC

#+RESULTS:
| id | first_name | last_name     | created_on                    |
|----+------------+---------------+-------------------------------|
|  1 | Captain    | Vegetable     | 2016-04-16 11:54:21.947152-07 |
|  2 | Samus      | Aran          | 2016-04-16 11:54:21.947152-07 |
|  3 | Bork       | the Barbarian | 2016-04-16 11:54:21.947152-07 |

SQL also supports a variety of different kinds of aggregations, by calling a
function (to perform the aggregation) and adding a ~GROUP BY~ clause (to specify
how data should be aggregated). For instance, how many of each kind of food do
we have?

#+BEGIN_SRC sql
SELECT kind, COUNT(*)
FROM food
GROUP BY kind
#+END_SRC

#+RESULTS:
| kind      | count |
|-----------+-------|
|           |     1 |
| meat      |     1 |
| vegetable |     2 |
| sandwich  |     1 |

**** Joins

***** The Basics of Joins
So being able to find all the things ~WHERE~ a certain condition is true, but it
lacks a certain pizzazz. After all: we've been working to make a /schema/ for
something called a "relational database". We keep talking about "primary keys".

What we're approaching is the notion of a /join/. When we join data, we take two
(or more!) tables and declare that they should be, in effect, combined in to a
single large table using common columns to line up values. Let's look at the
simplest example:

If I have table one as:
|-------+-------|
| col_1 | col_2 |
|-------+-------|
|     1 | cat   |
|-------+-------|

And table two as:
|-------+-------|
| col_1 | col_2 |
|-------+-------|
|     1 | meow  |
|-------+-------|

I can say, "in these two tables, ~col_1~ means the same thing in both tables", and
I could make a table like this:

|---------------+---------------+---------------+---------------|
| table_1.col_1 | table_2.col_1 | table_1.col_2 | table_2.col_2 |
|---------------+---------------+---------------+---------------|
|             1 |             1 | cat           | meow          |
|---------------+---------------+---------------+---------------|

In this example, we had a one-to-one relationship between table one and table
two. Let's make this example exactly three rows more complex; table one is now:

|-------+-------|
| col_1 | col_2 |
|-------+-------|
|     1 | cat   |
|     2 | dog   |
|-------+-------|

|-------+-------|
| col_1 | col_2 |
|-------+-------|
|     1 | meow  |
|     2 | woof  |
|     3 | quack |
|-------+-------|

Now we need to be more specific about how we do our join. There are three basic
kinds of joins:
- Inner
- Right/Left
- Outer

Let's see each of these with our two tables:

****** ~INNER JOIN~
In Postgres, by default, a ~JOIN~ is an ~INNER JOIN~ unless otherwise specified. An
~INNER JOIN~ is analogous to a set intersection, and returns only rows that match
perfectly from both sides of the join. So, even with our added row in table 2,
with an inner join our output is now:

|---------------+---------------+---------------+---------------|
| table_1.col_1 | table_2.col_1 | table_1.col_2 | table_2.col_2 |
|---------------+---------------+---------------+---------------|
|             1 |             1 | cat           | meow          |
|             2 |             2 | dog           | woof          |
|---------------+---------------+---------------+---------------|

~table_2~ row 3 is omitted entirely; it does not match exactly.

****** ~LEFT JOIN~ and ~RIGHT JOIN~
The ~LEFT JOIN~ says, "for every thing on the left, I want you to find me every
match available on the right." That is, it is a one-to-zero-or-more join. (A
~RIGHT JOIN~ is fairly uncommon, and is exactly the reverse of a ~LEFT JOIN~ -- a
zero-or-more-to-one join).

If we did ~table_1 LEFT JOIN table_2~, we'll get exactly the same result as our
inner join -- only rows from the right that exactly match rows on the left will
be kept, and now rows from the left will be dropped:

|---------------+---------------+---------------+---------------|
| table_1.col_1 | table_2.col_1 | table_1.col_2 | table_2.col_2 |
|---------------+---------------+---------------+---------------|
|             1 |             1 | cat           | meow          |
|             2 |             2 | dog           | woof          |
|---------------+---------------+---------------+---------------|

On the other hand, if we do ~table_2 LEFT JOIN table_1~, we get something
different:

|---------------+---------------+---------------+---------------|
| table_1.col_1 | table_2.col_1 | table_1.col_2 | table_2.col_2 |
|---------------+---------------+---------------+---------------|
|             1 |             1 | cat           | meow          |
|             2 |             2 | dog           | woof          |
|          NULL |             3 | NULL          | quack         |
|---------------+---------------+---------------+---------------|

Because a ~LEFT JOIN~ preserves every row on the left, we get ~NULLs~ where there
was no match from the right.

****** ~OUTER JOIN~
An ~OUTER JOIN~ returns all rows from both sides of the join. In our present
example, this will be the same as ~table_2 LEFT JOIN table_1~. Outer joins are
done very uncommonly.

****** An Important Thing to Know about ~INNER~ and ~OUTER~ joins
~INNER~ and ~OUTER~ joins both have a multiplicative effect if there is more than
one match on either side. Consider two tables like so:

~table_1~:
|-------+-------|
| col_1 | col_2 |
|-------+-------|
|     1 | foo   |
|     1 | bar   |
|     2 | bizz  |
|     2 | bazz  |
|-------+-------|

~table_2~
|-------+-------|
| col_1 | col_2 |
|-------+-------|
|     1 | poot  |
|     1 | scoot |

The ~INNER JOIN~ result would be:

|---------------+---------------+---------------+---------------|
| table_1.col_1 | table_2.col_1 | table_1.col_2 | table_2.col_2 |
|---------------+---------------+---------------+---------------|
|             1 |             1 | foo           | poot          |
|             1 |             1 | foo           | scoot         |
|             1 |             1 | bar           | poot          |
|             1 |             1 | bar           | scoot         |
|---------------+---------------+---------------+---------------|

And the ~OUTER JOIN~ would give you:
|---------------+---------------+---------------+---------------|
| table_1.col_1 | table_2.col_1 | table_1.col_2 | table_2.col_2 |
|---------------+---------------+---------------+---------------|
|             1 |             1 | foo           | poot          |
|             1 |             1 | foo           | scoot         |
|             1 |             1 | bar           | poot          |
|             1 |             1 | bar           | scoot         |
|             2 |          NULL | bizz          | NULL          |
|             2 |          NULL | bazz          | NULL          |
|---------------+---------------+---------------+---------------|

This is very usually not at all what you want, especially if you're going to
aggregate your results.

***** Joining our example data
What if we want to know how many foods Captain Vegetable loves? That's all three
tables -- this question cannot be answered without information from every
place. Fortuanely, SQL is awesome for this.

First, let's check out the SQL syntax:
#+BEGIN_SRC sql :eval never
SELECT table_one_alias.column, table_two_alias.different_column
FROM table_one AS table_one_alias -- We can alias long table names; this is optional, but typical.
LEFT JOIN table_two AS table_two_alias
ON table_one_alias.column = table_two_alias.column
#+END_SRC

#+BEGIN_SRC sql
  SELECT peeps.first_name
         , COUNT(DISTINCT foods.id) AS liked_foods
  FROM people AS peeps
  LEFT JOIN preferences AS prefs ON peeps.id = prefs.person_id
  LEFT JOIN food ON foods.id = prefs.food_id
  WHERE peeps.first_name = 'Captain'
        AND peeps.last_name = 'Vegetable'
        AND prefs.attitude = 'love'
  GROUP BY peeps.first_name
  ;
#+END_SRC

#+RESULTS:
| first_name | liked_foods |
|------------+-------------|
| Captain    |           2 |

**** Exercise
Let's write some SQL! Break out your text editor and ~psql~. Note that you're
going to have to find the PostgreSQL statements to make some of this exercise
work.

Figure out how to answer these questions using SQL:
1. Which food is the most liked?
2. Find the food that doesn't have a description.
3. Who likes the food with "beta carotene" in the description?

* <2017-03-28 Tue> -- ORMs
By now, I hope you've gotten a sense for how SQL operates -- the kinds of things
it can do, how it will help us work. You may also have a hunch that SQL isn't
going to be the easiest thing to use directly from, say, Python server code, and
you're right. When we write applications that talk to databases, we want to
spend our time creating application logic, not hand-writing SQL statements. This
isn't to say hand-written SQL doesn't have it's place. It's invaluable for
debugging and analysis -- questions like "this seems messy, what's wrong with
it" or "how common is this edge case" or "how many Foo do we get per day". It's
important to be able to reach in to your database and fiddle the bits. But it's
now how we'll write our applications.

*Note*: there are a lot of ways to wire an ORM and a web app together. I'm going
to do a demonstration using Flask and a Python ORM called SQLAlchemy, which I am
going to do in the most vanilla way possible. You can [[https://realpython.com/blog/python/flask-by-example-part-1-project-setup/][read more about]] getting
fancy integrating those two things, if you'd like, or you can just do this the,
y'know, vanilla way.

** Why ORM?
ORMs get us a couple different things:

- *Idiomatic*: SQL is terrific, but it's not idiomatic to anything but itself. An
  ORM lets you write clean, idiomatic code in the language of your application.
- *DRY*: Interacting with databases is such a common task that it makes very
  little sense to implement it yourself, when there are first-class libraries to
  do it for you.
- *Portable*: The ORM can handle SQL dialect changes for you, allowing your code
  to become far more "portable" across systems. (That is, if you write your code
  against a sqlite database, but then switch to Postgres, but then someone else
  wants to run you code backed by MySQL, it will be vastly easier to change
  databases if you're using an ORM than if you have to manually update all your
  SQL for portability.)

** Example Code
Today, we'll be mostly working through changes to our friend [[https://github.com/gastove/http-demo][http-demo]], so clone
that thinger and let's get motoring there.



* <2017-04-04 Tue> -- Testing. Testing. Testing.

* <2017-04-11 Tue> -- BASH BASH BASH: The Terminal, the Shell, and a Thousand Little Programs
** What on Earth Even Is This
** You Should Totally Get Familiar With:
*** ~ls~

#+BEGIN_SRC sh
ls -la $HOME
#+END_SRC

*** ~mkdir~
*** ~rm~
*** ~cat~
*** ~head~ and ~tail~
*** ~grep~
*** ~top~
*** ~ps~

** If you work on, or interact with, remote servers:
*** ~ssh~
*** ~ping~
*** ~rsync~

** Good to know is there:
*** ~uniq~
*** ~sort~
*** ~wc~
*** ~sed~
*** ~cut~
*** ~find~
*** ~xargs~
** For the brave: ~awk~
*** ~strace~
*** ~netstat~
** Useful bits, bobs, and snippets

* Footnotes

[fn:6] Here's a handy trick to make command 3 a little nicer:
1. Make a directory under your home directory and add it to your ~$PATH~. I use
   ~/Users/gastove/bin~. This gives you an easy, sudo-free place to put commands
   on your path, where your computer can find them.
2. Make a file in your handy ~bin~ directory called ~start-postgres~. Make the
   contents of that file be this:
#+BEGIN_SRC sh :eval never :exports code
  #!/usr/bin/env bash
  postgres -D /usr/local/var/postgres
#+END_SRC
3. Run ~sudo chmod a+x /where/you/put/the/file/start-postgres~. This makes the
   file executable.
4. Now you can run postgres whenevery you like with the ~start-postgres~ command.


[fn:5] Sometimes the scheme is also referred to as the /network transport/. Thank
god we aren't stuck with only one name for one thing -- can you imagine.

[fn:4] Are there more normal forms? Why yes! But they rapidly become more and
more difficult to reason about, and it's unlikely you'll need to understand
them. But, you can read about [[https://en.wikipedia.org/wiki/Second_normal_form][Second Normal Form]] and [[https://en.wikipedia.org/wiki/Third_normal_form][Third Normal Form]] if you
want to.

[fn:3] But please: don't.

[fn:2] The other option is DSA. For the most part, the winner between RSA and
DSA isn't clear, but: the math on which RSA is based is generally more
difficult, and RSA keys are longer. Also, RSA validation is more broadly
deployed.

[fn:1] We can find only git exactly using a regex with ~grep~:
#+BEGIN_SRC sh
ls -la /usr/local/bin | grep -e 'git$'
#+END_SRC

#+RESULTS:
: lrwxr-xr-x    1 rossdonaldson  wheel        27 Feb 26 12:22 git -> ../Cellar/git/2.7.2/bin/git

* Test
#+BEGIN_SRC sh
export PS1="$"
echo 5
#+END_SRC

#+RESULTS:
: 5
